From dc5f1ab82aaed633acd99628a4561a5544264f31 Mon Sep 17 00:00:00 2001
From: dtodoroff <d.todorov@vekatech.com>
Date: Mon, 11 Dec 2023 12:18:46 +0200
Subject: [PATCH] add vkrzv2l board support

---
 .../display/bridge/lontium,lt8912b.yaml       | 102 ++
 .../display/panel/fitipower,ek79007ad.yaml    |  53 ++
 Makefile                                      |   5 +-
 arch/arm64/boot/dts/renesas/Makefile          |   4 +
 arch/arm64/boot/dts/renesas/overlays/Makefile |  20 +
 .../boot/dts/renesas/overlays/vkrz-cm33.dts   |  75 ++
 .../dts/renesas/overlays/vkrz-csi-imx219.dts  |  28 +
 .../renesas/overlays/vkrz-dsi-av_disp2.dts    |  66 ++
 .../dts/renesas/overlays/vkrz-dsi-hdmi.dts    |  58 ++
 .../overlays/vkrz-dsi-vklcd-ee0700.dts        |  70 ++
 .../dts/renesas/overlays/vkrz-dsi-vklcd07.dts |  65 ++
 .../dts/renesas/overlays/vkrz-exp-pwm0.dts    |  32 +
 .../dts/renesas/overlays/vkrz-exp-pwm1.dts    |  34 +
 .../dts/renesas/overlays/vkrz-exp-pwm2.dts    |  32 +
 .../dts/renesas/overlays/vkrz-exp-riic2.dts   |  34 +
 .../dts/renesas/overlays/vkrz-exp-rspi1.dts   |  45 +
 .../dts/renesas/overlays/vkrz-exp-scif2.dts   |  33 +
 .../overlays/vkrz-exp-scif2_rts_cts.dts       |  36 +
 .../dts/renesas/overlays/vkrz-sdhi0-emmc.dts  |  44 +
 .../dts/renesas/overlays/vkrz-sdhi0-sdhi.dts  |  47 +
 arch/arm64/boot/dts/renesas/vkrzv2l.dts       | 874 ++++++++++++++++++
 arch/arm64/configs/vkrzv2l_defconfig          | 505 ++++++++++
 drivers/gpu/drm/bridge/Kconfig                |  16 +
 drivers/gpu/drm/bridge/Makefile               |   1 +
 drivers/gpu/drm/bridge/lontium-lt8912b.c      | 845 +++++++++++++++++
 drivers/gpu/drm/panel/Kconfig                 |  12 +-
 drivers/gpu/drm/panel/Makefile                |   1 +
 .../gpu/drm/panel/panel-fitipower-ek79007ad.c | 334 +++++++
 drivers/gpu/drm/panel/panel-ilitek-ili9881c.c | 291 +++++-
 drivers/gpu/drm/rcar-du/rzg2l_mipi_dsi.c      |  24 +
 drivers/mtd/spi-nor/macronix.c                |   4 +-
 drivers/net/phy/realtek.c                     |   6 +
 scripts/Makefile.lib                          |  10 +
 33 files changed, 3800 insertions(+), 6 deletions(-)
 create mode 100644 Documentation/devicetree/bindings/display/bridge/lontium,lt8912b.yaml
 create mode 100644 Documentation/devicetree/bindings/display/panel/fitipower,ek79007ad.yaml
 create mode 100644 arch/arm64/boot/dts/renesas/overlays/Makefile
 create mode 100755 arch/arm64/boot/dts/renesas/overlays/vkrz-cm33.dts
 create mode 100644 arch/arm64/boot/dts/renesas/overlays/vkrz-csi-imx219.dts
 create mode 100644 arch/arm64/boot/dts/renesas/overlays/vkrz-dsi-av_disp2.dts
 create mode 100644 arch/arm64/boot/dts/renesas/overlays/vkrz-dsi-hdmi.dts
 create mode 100644 arch/arm64/boot/dts/renesas/overlays/vkrz-dsi-vklcd-ee0700.dts
 create mode 100644 arch/arm64/boot/dts/renesas/overlays/vkrz-dsi-vklcd07.dts
 create mode 100644 arch/arm64/boot/dts/renesas/overlays/vkrz-exp-pwm0.dts
 create mode 100644 arch/arm64/boot/dts/renesas/overlays/vkrz-exp-pwm1.dts
 create mode 100644 arch/arm64/boot/dts/renesas/overlays/vkrz-exp-pwm2.dts
 create mode 100755 arch/arm64/boot/dts/renesas/overlays/vkrz-exp-riic2.dts
 create mode 100644 arch/arm64/boot/dts/renesas/overlays/vkrz-exp-rspi1.dts
 create mode 100644 arch/arm64/boot/dts/renesas/overlays/vkrz-exp-scif2.dts
 create mode 100644 arch/arm64/boot/dts/renesas/overlays/vkrz-exp-scif2_rts_cts.dts
 create mode 100644 arch/arm64/boot/dts/renesas/overlays/vkrz-sdhi0-emmc.dts
 create mode 100644 arch/arm64/boot/dts/renesas/overlays/vkrz-sdhi0-sdhi.dts
 create mode 100644 arch/arm64/boot/dts/renesas/vkrzv2l.dts
 create mode 100644 arch/arm64/configs/vkrzv2l_defconfig
 create mode 100644 drivers/gpu/drm/bridge/lontium-lt8912b.c
 create mode 100644 drivers/gpu/drm/panel/panel-fitipower-ek79007ad.c

diff --git a/Documentation/devicetree/bindings/display/bridge/lontium,lt8912b.yaml b/Documentation/devicetree/bindings/display/bridge/lontium,lt8912b.yaml
new file mode 100644
index 000000000000..05106373dbae
--- /dev/null
+++ b/Documentation/devicetree/bindings/display/bridge/lontium,lt8912b.yaml
@@ -0,0 +1,102 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/display/bridge/lontium,lt8912b.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Lontium LT8912B MIPI to HDMI Bridge
+
+maintainers:
+  - Adrien Grassein <adrien.grassein@gmail.com>
+
+description: |
+  The LT8912B is a bridge device which convert DSI to HDMI
+
+properties:
+  compatible:
+    enum:
+      - lontium,lt8912b
+
+  reg:
+    maxItems: 1
+
+  reset-gpios:
+    maxItems: 1
+    description: GPIO connected to active high RESET pin.
+
+  ports:
+    $ref: /schemas/graph.yaml#/properties/ports
+
+    properties:
+      port@0:
+        $ref: /schemas/graph.yaml#/properties/port
+        description:
+          Primary MIPI port for MIPI input
+
+        properties:
+          endpoint:
+            $ref: /schemas/media/video-interfaces.yaml#
+            unevaluatedProperties: false
+
+            properties:
+              data-lanes: true
+
+            required:
+              - data-lanes
+
+      port@1:
+        $ref: /schemas/graph.yaml#/properties/port
+        description: |
+          HDMI port, should be connected to a node compatible with the
+          hdmi-connector binding.
+
+    required:
+      - port@0
+      - port@1
+
+required:
+  - compatible
+  - reg
+  - reset-gpios
+  - ports
+
+additionalProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/gpio/gpio.h>
+
+    i2c4 {
+      #address-cells = <1>;
+      #size-cells = <0>;
+
+      hdmi-bridge@48 {
+        compatible = "lontium,lt8912b";
+        reg = <0x48>;
+        reset-gpios = <&max7323 0 GPIO_ACTIVE_LOW>;
+
+        ports {
+          #address-cells = <1>;
+          #size-cells = <0>;
+
+          port@0 {
+            reg = <0>;
+
+            hdmi_out_in: endpoint {
+              data-lanes = <0 1 2 3>;
+              remote-endpoint = <&mipi_dsi_out>;
+            };
+          };
+
+          port@1 {
+              reg = <1>;
+
+              endpoint {
+                  remote-endpoint = <&hdmi_in>;
+              };
+          };
+        };
+      };
+    };
+
+...
\ No newline at end of file
diff --git a/Documentation/devicetree/bindings/display/panel/fitipower,ek79007ad.yaml b/Documentation/devicetree/bindings/display/panel/fitipower,ek79007ad.yaml
new file mode 100644
index 000000000000..def13803755c
--- /dev/null
+++ b/Documentation/devicetree/bindings/display/panel/fitipower,ek79007ad.yaml
@@ -0,0 +1,53 @@
+# SPDX-License-Identifier: GPL-2.0
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/display/panel/fitipower,ek79007ad.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Fitipower EK79007AD based MIPI-DSI panels
+
+maintainers:
+  - Maxime Ripard <mripard@kernel.org>
+
+properties:
+  compatible:
+    items:
+      - enum:
+          - vekatech,vklcd07
+      - const: fitipower,ek79007ad
+
+  backlight: true
+  power-supply: true
+  reg: true
+  reset-gpios: true
+  lcd-model: true
+  lcd-model: true
+  dsi-lanes: true
+
+required:
+  - compatible
+  - power-supply
+  - reg
+  - reset-gpios
+
+additionalProperties: false
+
+examples:
+  - |
+
+    dsi {
+        #address-cells = <1>;
+        #size-cells = <0>;
+
+        panel@0 {
+            compatible = "vekatech,vklcd07", "fitipower,ek79007ad";
+            reg = <0>;
+            power-supply = <&reg_5p0v>;
+            backlight = <&backlight>;
+            reset-gpios = <&pinctrl RZG2L_GPIO(43, 1) GPIO_ACTIVE_LOW>;
+            dsi-lanes = <4>;
+            lcd-model = "vklcd07";
+        };
+    };
+
+...
diff --git a/Makefile b/Makefile
index e6b09052f222..f8555a82a596 100644
--- a/Makefile
+++ b/Makefile
@@ -1376,6 +1376,9 @@ ifneq ($(dtstree),)
 %.dtb: include/config/kernel.release scripts_dtc
 	$(Q)$(MAKE) $(build)=$(dtstree) $(dtstree)/$@

+%.dtbo: include/config/kernel.release scripts_dtc
+	$(Q)$(MAKE) $(build)=$(dtstree) $(dtstree)/$@
+
 PHONY += dtbs dtbs_install dtbs_check
 dtbs: include/config/kernel.release scripts_dtc
 	$(Q)$(MAKE) $(build)=$(dtstree)
@@ -1837,7 +1840,7 @@ clean: $(clean-dirs)
 	@find $(if $(KBUILD_EXTMOD), $(KBUILD_EXTMOD), .) $(RCS_FIND_IGNORE) \
 		\( -name '*.[aios]' -o -name '*.ko' -o -name '.*.cmd' \
 		-o -name '*.ko.*' \
-		-o -name '*.dtb' -o -name '*.dtb.S' -o -name '*.dt.yaml' \
+		-o -name '*.dtb' -o -name '*.dtb.S' -o -name '*.dt.yaml' -o -name '*.dtbo' \
 		-o -name '*.dwo' -o -name '*.lst' \
 		-o -name '*.su' -o -name '*.mod' \
 		-o -name '.*.d' -o -name '.*.tmp' -o -name '*.mod.c' \
diff --git a/arch/arm64/boot/dts/renesas/Makefile b/arch/arm64/boot/dts/renesas/Makefile
index 65754c43292b..30901e23f8ce 100644
--- a/arch/arm64/boot/dts/renesas/Makefile
+++ b/arch/arm64/boot/dts/renesas/Makefile
@@ -94,3 +94,7 @@ dtb-$(CONFIG_ARCH_R9A07G044) += r9a07g044l2-dev.dtb

 dtb-$(CONFIG_ARCH_R9A07G054) += r9a07g054l2-smarc.dtb
 dtb-$(CONFIG_ARCH_R9A07G044) += r9a07g054l2-dev.dtb
+
+DTC_FLAGS_vkrzv2l += -@
+dtb-$(CONFIG_ARCH_R9A07G054) += vkrzv2l.dtb
+subdir-$(CONFIG_ARCH_R9A07G054) += overlays
diff --git a/arch/arm64/boot/dts/renesas/overlays/Makefile b/arch/arm64/boot/dts/renesas/overlays/Makefile
new file mode 100644
index 000000000000..2a14502607bd
--- /dev/null
+++ b/arch/arm64/boot/dts/renesas/overlays/Makefile
@@ -0,0 +1,20 @@
+# SPDX-License-Identifier: GPL-2.0
+
+# required for overlay support
+DTC_FLAGS += -@
+
+dtb-y += vkrz-sdhi0-emmc.dtbo
+dtb-y += vkrz-sdhi0-sdhi.dtbo
+dtb-y += vkrz-dsi-hdmi.dtbo
+dtb-y += vkrz-dsi-av_disp2.dtbo
+dtb-y += vkrz-dsi-vklcd07.dtbo
+dtb-y += vkrz-dsi-vklcd-ee0700.dtbo
+dtb-y += vkrz-csi-imx219.dtbo
+dtb-y += vkrz-cm33.dtbo
+dtb-y += vkrz-exp-riic2.dtbo
+dtb-y += vkrz-exp-rspi1.dtbo
+dtb-y += vkrz-exp-scif2.dtbo
+dtb-y += vkrz-exp-scif2_rts_cts.dtbo
+dtb-y += vkrz-exp-pwm0.dtbo
+dtb-y += vkrz-exp-pwm1.dtbo
+dtb-y += vkrz-exp-pwm2.dtbo
diff --git a/arch/arm64/boot/dts/renesas/overlays/vkrz-cm33.dts b/arch/arm64/boot/dts/renesas/overlays/vkrz-cm33.dts
new file mode 100755
index 000000000000..6138c030db4d
--- /dev/null
+++ b/arch/arm64/boot/dts/renesas/overlays/vkrz-cm33.dts
@@ -0,0 +1,75 @@
+/*
+ * Copyright 2023 Vekatech
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+
+
+/ {
+	compatible = "vekatech,vkrzv2l", "renesas,r9a07g054";
+	fragment@2 {
+		target-path = "/";
+		__overlay__ {
+			#address-cells = <2>;
+			#size-cells = <2>;
+
+			vring-ctl0@43000000 {
+				compatible = "vring_uio";
+				reg = <0x0 0x43000000 0x0 0x100000>;
+				no-map;
+			};
+
+			vring-ctl1@43100000 {
+				compatible = "vring_uio";
+				reg = <0x0 0x43100000 0x0 0x100000>;
+				no-map;
+			};
+
+			vring-shm0@43200000 {
+				compatible = "shm_uio";
+				reg = <0x0 0x43200000 0x0 0x300000>;
+				no-map;
+			};
+
+			vring-shm1@43500000 {
+				compatible = "shm_uio";
+				reg = <0x0 0x43500000 0x0 0x300000>;
+				no-map;
+			};
+
+			rsctbl@42f00000 {
+				compatible = "shm_uio";
+				reg = <0x0 0x42f00000 0x0 0x1000>;
+				no-map;
+			};
+
+			mhu-shm@42f01000 {
+				compatible = "shm_uio";
+				reg = <0x0 0x42f01000 0x0 0x1000>;
+				no-map;
+			};
+
+			mbox-uio@10400000 {
+				compatible = "mbox_uio";
+				reg = <0x0 0x10400000 0x0 0x1000>;
+				interrupt-parent = <&gic>;
+				interrupts = <GIC_SPI 75 IRQ_TYPE_LEVEL_HIGH>;
+				status = "okay";
+			};
+		};
+	};
+};
+
diff --git a/arch/arm64/boot/dts/renesas/overlays/vkrz-csi-imx219.dts b/arch/arm64/boot/dts/renesas/overlays/vkrz-csi-imx219.dts
new file mode 100644
index 000000000000..7e2457e32ebb
--- /dev/null
+++ b/arch/arm64/boot/dts/renesas/overlays/vkrz-csi-imx219.dts
@@ -0,0 +1,28 @@
+/*
+ * Copyright 2023 Vekatech
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+/dts-v1/;
+/plugin/;
+
+&cru {
+	status = "okay";
+};
+
+&csi2 {
+	status = "okay";
+};
+
+&imx219 {
+	status = "okay";
+};
diff --git a/arch/arm64/boot/dts/renesas/overlays/vkrz-dsi-av_disp2.dts b/arch/arm64/boot/dts/renesas/overlays/vkrz-dsi-av_disp2.dts
new file mode 100644
index 000000000000..6150787627b6
--- /dev/null
+++ b/arch/arm64/boot/dts/renesas/overlays/vkrz-dsi-av_disp2.dts
@@ -0,0 +1,66 @@
+/*
+ * Copyright 2023 Vekatech
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+// Avnet Display AES-ACC-MAAX-DISP2
+
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/pinctrl/rzg2l-pinctrl.h>
+#include <dt-bindings/gpio/gpio.h>
+
+&du {
+	status = "okay";
+};
+
+&dsi0 {
+	status = "okay";
+	ports {
+		port@1 {
+			dsi0_out: endpoint {
+				remote-endpoint = <&panel_in>;
+			};
+		};
+	};
+};
+
+&mipi_panel {
+	status = "okay";
+	compatible = "avnet,ph720128t005","ilitek,ili9881c";
+	lcd-model = "ph720128t005";
+	switch-gpios = <&pinctrl RZG2L_GPIO(43, 0) GPIO_ACTIVE_HIGH>;
+	reset-gpios  = <&pinctrl RZG2L_GPIO(43, 3) GPIO_ACTIVE_LOW>;
+	dsi-lanes = <2>;
+	port {
+		panel_in: endpoint {
+			remote-endpoint = <&dsi0_out>;
+		};
+	};
+};
+
+&gpt5 {
+	status = "okay";
+};
+
+&backlight {
+	status = "okay";
+};
+
+&gt911 {
+	reset-gpios = <&pinctrl RZG2L_GPIO(43, 1) GPIO_ACTIVE_HIGH>; /* DSI_TS_RST */
+	touchscreen-size-x = <720>;
+	touchscreen-size-y = <1280>;
+	status = "okay";
+};
+
diff --git a/arch/arm64/boot/dts/renesas/overlays/vkrz-dsi-hdmi.dts b/arch/arm64/boot/dts/renesas/overlays/vkrz-dsi-hdmi.dts
new file mode 100644
index 000000000000..0bb63868b214
--- /dev/null
+++ b/arch/arm64/boot/dts/renesas/overlays/vkrz-dsi-hdmi.dts
@@ -0,0 +1,58 @@
+/*
+ * Copyright 2023 Vekatech
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+/dts-v1/;
+/plugin/;
+
+&du {
+	status = "okay";
+	dsi-lanes = <4>;
+};
+
+&hdmi_con {
+	status = "okay";
+};
+
+&dsi0 {
+	status = "okay";
+
+	ports {
+		port@1 {
+			dsi0_out: endpoint {
+				remote-endpoint = <&hdmi_in>;
+				data-lanes = <0 1 2 3>;
+			};
+		};
+	};
+};
+
+&lt8912b {
+	status = "okay";
+
+	ports {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		port@0 {
+			reg = <0>;
+
+			hdmi_in: endpoint {
+				data-lanes = <0 1 2 3>;
+				remote-endpoint = <&dsi0_out>;
+			};
+		};
+
+	};
+};
+
diff --git a/arch/arm64/boot/dts/renesas/overlays/vkrz-dsi-vklcd-ee0700.dts b/arch/arm64/boot/dts/renesas/overlays/vkrz-dsi-vklcd-ee0700.dts
new file mode 100644
index 000000000000..94e1b22aff1d
--- /dev/null
+++ b/arch/arm64/boot/dts/renesas/overlays/vkrz-dsi-vklcd-ee0700.dts
@@ -0,0 +1,70 @@
+/*
+ * Copyright 2023 Vekatech
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/pinctrl/rzg2l-pinctrl.h>
+#include <dt-bindings/gpio/gpio.h>
+
+&du {
+	status = "okay";
+};
+
+&dsi0 {
+	status = "okay";
+	ports {
+		port@1 {
+			dsi0_out: endpoint {
+				remote-endpoint = <&panel_in>;
+			};
+		};
+	};
+};
+
+&mipi_panel {
+	status = "okay";
+	compatible = "vekatech,vklcd07","fitipower,ek79007ad";
+
+	reset-gpios = <&pinctrl RZG2L_GPIO(43, 3) (GPIO_ACTIVE_LOW|GPIO_OPEN_DRAIN)>;
+	lcd-model = "vklcd07";
+	dsi-lanes = <4>;
+	port {
+		panel_in: endpoint {
+			remote-endpoint = <&dsi0_out>;
+		};
+	};
+};
+
+&gpt5 {
+	status = "okay";
+};
+
+&backlight {
+	status = "okay";
+};
+
+&pinctrl {
+	hdmi-rst-hog {
+		gpio-hog;
+		gpios = <RZG2L_GPIO(42, 0) GPIO_ACTIVE_HIGH>;
+		output-low;
+		line-name = "hdmi_rst";
+	};
+};
+
+&mxt1066t2 {
+	status = "okay";
+	reset-gpios = <&pinctrl RZG2L_GPIO(43, 1) GPIO_ACTIVE_LOW>;
+};
diff --git a/arch/arm64/boot/dts/renesas/overlays/vkrz-dsi-vklcd07.dts b/arch/arm64/boot/dts/renesas/overlays/vkrz-dsi-vklcd07.dts
new file mode 100644
index 000000000000..6444373d5f29
--- /dev/null
+++ b/arch/arm64/boot/dts/renesas/overlays/vkrz-dsi-vklcd07.dts
@@ -0,0 +1,65 @@
+/*
+ * Copyright 2023 Vekatech
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/pinctrl/rzg2l-pinctrl.h>
+#include <dt-bindings/gpio/gpio.h>
+
+&du {
+	status = "okay";
+};
+
+&dsi0 {
+	status = "okay";
+	ports {
+		port@1 {
+			dsi0_out: endpoint {
+				remote-endpoint = <&panel_in>;
+			};
+		};
+	};
+};
+
+&mipi_panel {
+	status = "okay";
+	compatible = "vekatech,vklcd07","fitipower,ek79007ad";
+
+	reset-gpios = <&pinctrl RZG2L_GPIO(43, 1) GPIO_ACTIVE_LOW>;
+	lcd-model = "vklcd07";
+	dsi-lanes = <4>;
+	port {
+		panel_in: endpoint {
+			remote-endpoint = <&dsi0_out>;
+		};
+	};
+};
+
+&gpt5 {
+	status = "okay";
+};
+
+&backlight {
+	status = "okay";
+};
+
+&gt911 {
+	status = "okay";
+	touchscreen-swapped-x-y;
+	touchscreen-inverted-y;
+	touchscreen-size-y = <1024>;
+	touchscreen-size-x = <600>;
+	reset-gpios = <&pinctrl RZG2L_GPIO(43, 3) GPIO_ACTIVE_HIGH>;
+};
diff --git a/arch/arm64/boot/dts/renesas/overlays/vkrz-exp-pwm0.dts b/arch/arm64/boot/dts/renesas/overlays/vkrz-exp-pwm0.dts
new file mode 100644
index 000000000000..03773c570010
--- /dev/null
+++ b/arch/arm64/boot/dts/renesas/overlays/vkrz-exp-pwm0.dts
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2023 Vekatech
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/pinctrl/rzg2l-pinctrl.h>
+
+&gpt7 {
+	status = "okay";
+
+	pinctrl-0 = <&gpt7_pins>;
+	pinctrl-names = "default";
+	channel="channel_B";
+};
+
+&pinctrl {
+	gpt7_pins: gpt7 {
+		pinmux = <RZG2L_PORT_PINMUX(17, 1, 3)>; /* Channel B */
+	};
+};
diff --git a/arch/arm64/boot/dts/renesas/overlays/vkrz-exp-pwm1.dts b/arch/arm64/boot/dts/renesas/overlays/vkrz-exp-pwm1.dts
new file mode 100644
index 000000000000..bc4ba3f68e37
--- /dev/null
+++ b/arch/arm64/boot/dts/renesas/overlays/vkrz-exp-pwm1.dts
@@ -0,0 +1,34 @@
+/*
+ * Copyright 2023 Vekatech
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/pinctrl/rzg2l-pinctrl.h>
+
+&mtu6 {
+	status = "okay";
+
+	pinctrl-0 = <&mtu6_pins>;
+	pinctrl-names = "default";
+	/* Enable PWM mode 1 out for MTIOC6A pins. */
+	pwm_mode1 = <6 1>;
+};
+
+&pinctrl {
+	mtu6_pins: mtu6 {
+		pinmux = <RZG2L_PORT_PINMUX(10, 0, 3)>; /* MTIOC6A */
+	};
+};
+
diff --git a/arch/arm64/boot/dts/renesas/overlays/vkrz-exp-pwm2.dts b/arch/arm64/boot/dts/renesas/overlays/vkrz-exp-pwm2.dts
new file mode 100644
index 000000000000..7de062e99845
--- /dev/null
+++ b/arch/arm64/boot/dts/renesas/overlays/vkrz-exp-pwm2.dts
@@ -0,0 +1,32 @@
+/*
+ * Copyright 2023 Vekatech
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/pinctrl/rzg2l-pinctrl.h>
+
+&gpt4 {
+	status = "okay";
+
+	pinctrl-0 = <&gpt4_pins>;
+	pinctrl-names = "default";
+	channel="channel_B";
+};
+
+&pinctrl {
+	gpt4_pins: gpt4 {
+		pinmux = <RZG2L_PORT_PINMUX(15, 1, 3)>; /* Channel B */
+	};
+};
diff --git a/arch/arm64/boot/dts/renesas/overlays/vkrz-exp-riic2.dts b/arch/arm64/boot/dts/renesas/overlays/vkrz-exp-riic2.dts
new file mode 100755
index 000000000000..2ad950863fa8
--- /dev/null
+++ b/arch/arm64/boot/dts/renesas/overlays/vkrz-exp-riic2.dts
@@ -0,0 +1,34 @@
+/*
+ * Copyright 2023 Vekatech
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/pinctrl/rzg2l-pinctrl.h>
+
+/* 40-pin extended GPIO, expanded into UART, SPI, I2C, PWM and other interfaces */
+
+&pinctrl {
+	i2c2_pins: i2c2 {
+		pinmux = <RZG2L_PORT_PINMUX(46, 0, 4)>, /* SDA */
+			 <RZG2L_PORT_PINMUX(46, 1, 4)>; /* SCL */
+	};
+};
+
+&i2c2 {
+	pinctrl-0 = <&i2c2_pins>;
+	pinctrl-names = "default";
+	clock-frequency = <400000>;
+	status = "okay";
+};
diff --git a/arch/arm64/boot/dts/renesas/overlays/vkrz-exp-rspi1.dts b/arch/arm64/boot/dts/renesas/overlays/vkrz-exp-rspi1.dts
new file mode 100644
index 000000000000..7a372ab2d3b1
--- /dev/null
+++ b/arch/arm64/boot/dts/renesas/overlays/vkrz-exp-rspi1.dts
@@ -0,0 +1,45 @@
+/*
+ * Copyright 2023 Vekatech
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/pinctrl/rzg2l-pinctrl.h>
+
+/* 40-pin extended GPIO, expanded into UART, SPI, I2C, PWM and other interfaces */
+
+&pinctrl {
+	spi1_pins: spi1 {
+		pinmux = <RZG2L_PORT_PINMUX(44, 0, 1)>, /* CK */
+			 <RZG2L_PORT_PINMUX(44, 1, 1)>, /* MOSI */
+			 <RZG2L_PORT_PINMUX(44, 2, 1)>, /* MISO */
+			 <RZG2L_PORT_PINMUX(44, 3, 1)>; /* SSL */
+	};
+};
+
+&spi1 {
+	pinctrl-0 = <&spi1_pins>;
+	pinctrl-names = "default";
+	dmas = <&dmac 0x2e99>, <&dmac 0x2e9a>;
+	dma-names = "tx", "rx";
+	status = "okay";
+
+	#address-cells = <1>;
+	#size-cells = <0>;
+	spidev@0 {
+		compatible = "semtech,sx1301";
+		reg = <0>;
+		spi-max-frequency = <2000000>;
+	};
+};
diff --git a/arch/arm64/boot/dts/renesas/overlays/vkrz-exp-scif2.dts b/arch/arm64/boot/dts/renesas/overlays/vkrz-exp-scif2.dts
new file mode 100644
index 000000000000..30b87e2dc769
--- /dev/null
+++ b/arch/arm64/boot/dts/renesas/overlays/vkrz-exp-scif2.dts
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2023 Vekatech
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/pinctrl/rzg2l-pinctrl.h>
+
+/* 40-pin extended GPIO, expanded into UART, SPI, I2C, PWM and other interfaces */
+
+&pinctrl {
+	scif2_pins: scif2 {
+		pinmux = <RZG2L_PORT_PINMUX(48, 0, 1)>, /* TxD */
+			 <RZG2L_PORT_PINMUX(48, 1, 1)>; /* RxD */
+	};
+};
+
+&scif2 {
+	pinctrl-0 = <&scif2_pins>;
+	pinctrl-names = "default";
+	status = "okay";
+};
diff --git a/arch/arm64/boot/dts/renesas/overlays/vkrz-exp-scif2_rts_cts.dts b/arch/arm64/boot/dts/renesas/overlays/vkrz-exp-scif2_rts_cts.dts
new file mode 100644
index 000000000000..4a82256800af
--- /dev/null
+++ b/arch/arm64/boot/dts/renesas/overlays/vkrz-exp-scif2_rts_cts.dts
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2023 Vekatech
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/pinctrl/rzg2l-pinctrl.h>
+
+/* 40-pin extended GPIO, expanded into UART, SPI, I2C, PWM and other interfaces */
+
+&pinctrl {
+	scif2_pins: scif2 {
+		pinmux = <RZG2L_PORT_PINMUX(48, 0, 1)>, /* TxD */
+			 <RZG2L_PORT_PINMUX(48, 1, 1)>, /* RxD */
+			 <RZG2L_PORT_PINMUX(48, 3, 1)>, /* CTS# */
+			 <RZG2L_PORT_PINMUX(48, 4, 1)>; /* RTS# */
+	};
+};
+
+&scif2 {
+	pinctrl-0 = <&scif2_pins>;
+	pinctrl-names = "default";
+	uart-has-rtscts;
+	status = "okay";
+};
diff --git a/arch/arm64/boot/dts/renesas/overlays/vkrz-sdhi0-emmc.dts b/arch/arm64/boot/dts/renesas/overlays/vkrz-sdhi0-emmc.dts
new file mode 100644
index 000000000000..4fb3fe5606c4
--- /dev/null
+++ b/arch/arm64/boot/dts/renesas/overlays/vkrz-sdhi0-emmc.dts
@@ -0,0 +1,44 @@
+/*
+ * Copyright 2023 Vekatech
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/pinctrl/rzg2l-pinctrl.h>
+#include <dt-bindings/gpio/gpio.h>
+
+&pinctrl {
+	sd0-dev-sel-hog {
+		gpio-hog;
+		gpios = <RZG2L_GPIO(41, 1) GPIO_ACTIVE_HIGH>;
+		output-high;
+		line-name = "sd0_dev_sel";
+	};
+};
+
+/* for eMMC */
+&sdhi0 {
+	pinctrl-0 = <&sdhi0_emmc_pins>;
+	pinctrl-1 = <&sdhi0_emmc_pins>;
+	pinctrl-names = "default", "state_uhs";
+
+	vmmc-supply = <&reg_3p3v>;
+	vqmmc-supply = <&reg_1p8v>;
+	bus-width = <8>;
+	mmc-hs200-1_8v;
+	non-removable;
+	fixed-emmc-driver-type = <1>;
+	status = "okay";
+};
+
diff --git a/arch/arm64/boot/dts/renesas/overlays/vkrz-sdhi0-sdhi.dts b/arch/arm64/boot/dts/renesas/overlays/vkrz-sdhi0-sdhi.dts
new file mode 100644
index 000000000000..6eb546412bbf
--- /dev/null
+++ b/arch/arm64/boot/dts/renesas/overlays/vkrz-sdhi0-sdhi.dts
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2023 Vekatech
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+/dts-v1/;
+/plugin/;
+
+#include <dt-bindings/pinctrl/rzg2l-pinctrl.h>
+#include <dt-bindings/gpio/gpio.h>
+
+&pinctrl {
+	sd0-dev-sel-hog {
+		gpio-hog;
+		gpios = <RZG2L_GPIO(41, 1) GPIO_ACTIVE_HIGH>;
+		output-high;
+		line-name = "sd0_dev_sel";
+	};
+};
+
+&vccq_sdhi0 {
+	gpios = <&pinctrl RZG2L_GPIO(32, 0) GPIO_ACTIVE_HIGH>;
+};
+
+/* for SD Card */
+&sdhi0 {
+	pinctrl-0 = <&sdhi0_pins>;
+	pinctrl-1 = <&sdhi0_pins_uhs>;
+	pinctrl-names = "default", "state_uhs";
+
+	vmmc-supply = <&reg_3p3v>;
+	vqmmc-supply = <&vccq_sdhi0>;
+	bus-width = <4>;
+	sd-uhs-sdr50;
+	sd-uhs-sdr104;
+	status = "okay";
+};
+
diff --git a/arch/arm64/boot/dts/renesas/vkrzv2l.dts b/arch/arm64/boot/dts/renesas/vkrzv2l.dts
new file mode 100644
index 000000000000..a5c9d2661606
--- /dev/null
+++ b/arch/arm64/boot/dts/renesas/vkrzv2l.dts
@@ -0,0 +1,874 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Device Tree Source for the Vekatech (VKRZV2L Dual Cortex-A55)
+ *
+ * Copyright (C) 2022 Vekatech.
+ */
+
+/dts-v1/;
+
+#include "r9a07g054l2.dtsi"
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/pinctrl/rzg2l-pinctrl.h>
+#include <dt-bindings/input/input.h>
+
+
+/ {
+	model = "Vekatech,vkrzv2l";
+	compatible = "vekatech,vkrzv2l", "renesas,r9a07g054l2", "renesas,r9a07g054";
+
+	aliases {
+		ethernet0 = &eth0;
+		ethernet1 = &eth1;
+		serial0 = &scif0;
+		serial1 = &scif1;
+		serial2 = &scif2;
+		serial3 = &scif3;
+		i2c0 = &i2c0;
+		i2c1 = &i2c1;
+		i2c3 = &i2c3;
+		mmc0 = &sdhi0;
+	};
+
+	chosen {
+		bootargs = "ignore_loglevel";
+		stdout-path = "serial0:115200n8";
+	};
+
+	memory@48000000 {
+		device_type = "memory";
+		/* first 128MB is reserved for secure area. */
+		reg = <0x0 0x48000000 0x0 0x78000000>;
+	};
+
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		global_cma: linux,cma@58000000 {
+			compatible = "shared-dma-pool";
+			linux,cma-default;
+			reusable;
+			reg = <0x0 0x58000000 0x0 0x10000000>;
+		};
+
+		mmp_reserved: linux,multimedia {
+			compatible = "shared-dma-pool";
+			reusable;
+			reg = <0x00000000 0x68000000 0x0 0x10000000>;
+		};
+
+		/* device specific region for contiguous allocations */
+		drp_reserved: DRP-AI {
+			reusable;
+			reg = <0x0 0x80000000 0x0 0x20000000>;
+		};
+
+		image_buf0: image_buf@0 {
+			compatible = "shared-dma-pool";
+			reusable;
+			reg = <0x0 0xB0000000 0x0 0x04000000>;
+			label = "image_buf0";
+		};
+
+		isp_work0: SIMPLE_ISP {
+			reusable;
+			reg = <0x0 0xB4000000 0x0 0x03000000>;
+		};
+
+	};
+
+	mmngr {
+		compatible = "renesas,mmngr";
+		memory-region = <&mmp_reserved>;
+	};
+
+	mmngrbuf {
+		compatible = "renesas,mmngrbuf";
+	};
+
+	vspm_if {
+		compatible = "renesas,vspm_if";
+	};
+
+	reg_5p0v: regulator0 {
+		compatible = "regulator-fixed";
+		regulator-name = "MAIN-5.0V";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		regulator-boot-on;
+		regulator-always-on;
+	};
+
+	reg_1p8v: regulator1 {
+		compatible = "regulator-fixed";
+		regulator-name = "fixed-1.8V";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		regulator-boot-on;
+		regulator-always-on;
+	};
+
+	reg_3p3v: regulator2 {
+		compatible = "regulator-fixed";
+		regulator-name = "fixed-3.3V";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		regulator-boot-on;
+		regulator-always-on;
+	};
+
+	reg_1p1v: regulator-vdd-core {
+		compatible = "regulator-fixed";
+		regulator-name = "fixed-1.1V";
+		regulator-min-microvolt = <1100000>;
+		regulator-max-microvolt = <1100000>;
+		regulator-boot-on;
+		regulator-always-on;
+	};
+
+	vccq_sdhi0: regulator-vccq-sdhi0 {
+		compatible = "regulator-gpio";
+		regulator-name = "SDHI0 VccQ";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <3300000>;
+		gpios-states = <1>;
+		states = <3300000 1>, <1800000 0>;
+		regulator-boot-on;
+		regulator-always-on;
+	};
+
+	vbus0_5v: regulator-vbus0-usb {
+		compatible = "regulator-fixed";
+		regulator-name = "USB2_VBUS0";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		regulator-always-on;
+	};
+
+	imx219_vana_2v8: 2p8v {
+		compatible = "regulator-fixed";
+		regulator-name = "camera_vana";
+		regulator-min-microvolt = <2800000>;
+		regulator-max-microvolt = <2800000>;
+		regulator-always-on;
+	};
+
+	imx219_vdig_1v8: 1p8v {
+		compatible = "regulator-fixed";
+		regulator-name = "camera_vdig";
+		regulator-min-microvolt = <1500000>;
+		regulator-max-microvolt = <1500000>;
+		regulator-always-on;
+	};
+
+	imx219_vddl_1v2: 1p2v {
+		compatible = "regulator-fixed";
+		regulator-name = "camera_vddl";
+		regulator-min-microvolt = <1200000>;
+		regulator-max-microvolt = <1200000>;
+		regulator-always-on;
+	};
+
+	audio_mclock: audio_mclock {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <11289600>;
+	};
+
+	clk_ext_camera: clk_ext_camera {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <24000000>;
+	};
+
+	leds {
+		compatible = "gpio-leds";
+		led_red {
+			gpios = <&pinctrl RZG2L_GPIO(8, 2) GPIO_ACTIVE_HIGH>;
+			default-state = "off";
+		};
+
+		led_green {
+			gpios = <&pinctrl RZG2L_GPIO(17, 2) GPIO_ACTIVE_HIGH>;
+			linux,default-trigger = "heartbeat";
+			default-state = "on";
+		};
+
+		led_blue {
+			gpios = <&pinctrl RZG2L_GPIO(19, 1) GPIO_ACTIVE_HIGH>;
+			default-state = "off";
+		};
+
+		led_yellow {
+			gpios = <&pinctrl RZG2L_GPIO(15, 0) GPIO_ACTIVE_HIGH>;
+			default-state = "off";
+		};
+
+		usb0_sel {
+			gpios = <&pinctrl RZG2L_GPIO(5, 2) GPIO_ACTIVE_HIGH>;
+			default-state = "off";
+		};
+	};
+
+	keys {
+		compatible = "gpio-keys";
+		user_key {
+			label = "SB2";
+			linux,code = <KEY_1>;
+			debounce-interval = <20>;
+			interrupt-parent = <&pinctrl>;
+			interrupts = <RZG2L_GPIO(39, 0) IRQ_TYPE_LEVEL_LOW>;
+		};
+	};
+
+	sound-da7212 {
+		compatible = "simple-audio-card";
+		simple-audio-card,name = "audio-da7212";
+		simple-audio-card,format = "i2s";
+		simple-audio-card,bitclock-master = <&cpu_dai>;
+		simple-audio-card,frame-master = <&cpu_dai>;
+
+		simple-audio-card,widgets =
+			"Microphone", "Microphone Jack",
+			"Headphone", "Headphone Jack";
+		simple-audio-card,routing =
+			"MIC1", "Microphone Jack",
+			"Microphone Jack", "Mic Bias 1",
+			"Headphone Jack", "HPL",
+			"Headphone Jack", "HPR";
+
+		cpu_dai: simple-audio-card,cpu {
+			sound-dai = <&ssi0>;
+		};
+
+		codec_dai: simple-audio-card,codec {
+			sound-dai = <&da7212>;
+			clocks = <&versa3 3>;
+		};
+	};
+
+	hdmi_con: hdmi_con {
+		compatible = "hdmi-connector";
+		label = "micro-HDMI";
+		type = "d";
+		status = "disabled";
+
+		ddc-i2c-bus = <&i2c1>;
+
+		hpd-gpios = <&pinctrl RZG2L_GPIO(13, 0) GPIO_ACTIVE_HIGH>;
+
+		port {
+			hdmi_con_in: endpoint {
+				remote-endpoint = <&hdmi_bridge_out>;
+			};
+		};
+	};
+
+	backlight: backlight {
+		compatible = "pwm-backlight";
+		pwms = <&gpt5 0 40000 0>;
+		brightness-levels = <0 8 32 64 96 128 160 192 224 255>;
+		default-brightness-level = <8>;
+		power-supply = <&reg_5p0v>;
+		status = "disabled";
+	};
+
+	x1_clk: x1-clock {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <24000000>;
+	};
+};
+
+&extal_clk {
+	clock-frequency = <24000000>;
+};
+
+&audio_clk1{
+	clock-frequency = <11289600>;
+};
+
+&audio_clk2{
+	clock-frequency = <12288000>;
+};
+
+&gpu {
+	mali-supply = <&reg_1p1v>;
+};
+
+&wdt0 {
+	status = "okay";
+	timeout-sec = <60>;
+};
+
+&wdt1 {
+	status = "okay";
+	timeout-sec = <60>;
+};
+
+&wdt2 {
+	status = "okay";
+	timeout-sec = <60>;
+};
+
+&ostm1 {
+	status = "okay";
+};
+
+&mtu3 {
+	status = "okay";
+};
+
+&scif0 {
+	pinctrl-0 = <&scif0_pins>;
+	pinctrl-names = "default";
+	status = "okay";
+};
+
+&scif1 {
+	pinctrl-0 = <&scif1_pins>;
+	pinctrl-names = "default";
+	status = "okay";
+};
+
+&scif3 {
+	pinctrl-0 = <&scif3_pins>;
+	pinctrl-names = "default";
+	status = "okay";
+};
+
+&ehci0 {
+	memory-region = <&global_cma>;
+	dr_mode = "otg";
+	status = "okay";
+};
+
+&ohci0 {
+	memory-region = <&global_cma>;
+	dr_mode = "otg";
+	status = "okay";
+};
+
+&ehci1 {
+	memory-region = <&global_cma>;
+	status = "okay";
+};
+
+&ohci1 {
+	memory-region = <&global_cma>;
+	status = "okay";
+};
+
+&hsusb {
+	dr_mode = "otg";
+	status = "okay";
+};
+
+&phyrst {
+	status = "okay";
+};
+
+&usb2_phy0 {
+	pinctrl-0 = <&usb0_pins>;
+	pinctrl-names = "default";
+
+	vbus-supply = <&vbus0_5v>;
+	status = "okay";
+};
+
+&usb2_phy1 {
+	pinctrl-0 = <&usb1_pins>;
+	pinctrl-names = "default";
+
+	vbus-supply = <&vbus0_5v>;
+	status = "okay";
+};
+
+&eth0 {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&eth0_pins>;
+	phy-handle = <&phy0>;
+	phy-mode = "rgmii-id";
+	status = "okay";
+
+	/* Realtek RTL8211F (0x001cc916) */
+	phy0: ethernet-phy@0 {
+		reg = <0>;
+		reset-assert-us = <15000>;
+		reset-deassert-us = <100000>;
+		reset-gpios = <&pinctrl RZG2L_GPIO(39, 2) GPIO_ACTIVE_LOW>;
+		interrupt-parent = <&pinctrl>;
+		interrupts = <RZG2L_GPIO(1, 0) IRQ_TYPE_LEVEL_LOW>;
+	};
+};
+
+&eth1 {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&eth1_pins>;
+	phy-handle = <&phy1>;
+	phy-mode = "rgmii-id";
+	status = "okay";
+
+	/* Realtek RTL8211F (0x001cc916) */
+	phy1: ethernet-phy@0 {
+		reg = <0>;
+		reset-assert-us = <15000>;
+		reset-deassert-us = <100000>;
+		reset-gpios = <&pinctrl RZG2L_GPIO(7, 0) GPIO_ACTIVE_LOW>;
+		interrupt-parent = <&pinctrl>;
+		interrupts = <RZG2L_GPIO(1, 1) IRQ_TYPE_LEVEL_LOW>;
+	};
+};
+
+&csi2 {
+	status = "disabled";
+	ports {
+		port {
+			csi2_in: endpoint {
+				clock-lanes = <0>;
+				data-lanes = <1 2>;
+				remote-endpoint = <&imx219_to_csi>;
+			};
+		};
+	};
+};
+
+&i2c0 {
+	pinctrl-0 = <&i2c0_pins>;
+	pinctrl-names = "default";
+
+	clock-frequency = <100000>;
+	status = "okay";
+
+	imx219: camera@10 {
+		compatible = "sony,imx219";
+		reg = <0x10>;
+		status = "disabled";
+
+		clock-names = "xclk";
+		clocks = <&clk_ext_camera>;
+		clock-frequency = <24000000>;
+
+		VANA-supply = <&imx219_vana_2v8>;
+		VDIG-supply = <&imx219_vdig_1v8>;
+		VDDL-supply = <&imx219_vddl_1v2>;
+
+		reset-gpios = <&pinctrl RZG2L_GPIO(2, 0) GPIO_ACTIVE_HIGH>;
+
+		port {
+			imx219_to_csi: endpoint {
+				remote-endpoint = <&csi2_in>;
+				data-lanes = <1 2>;
+				clock-noncontinuous;
+				link-frequencies = /bits/ 64 <456000000>;
+			};
+		};
+	};
+};
+
+&i2c1 {
+	pinctrl-0 = <&i2c1_pins>;
+	pinctrl-names = "default";
+	clock-frequency = <100000>;
+	i2c-scl-falling-time-ns = <20>;
+	i2c-scl-rising-time-ns = <350>;
+
+	status = "okay";
+
+	lt8912b: hdmi_bridge@48 {
+		compatible = "lontium,lt8912b";
+		reg = <0x48>;
+
+		status = "disabled";
+
+		reset-gpios = <&pinctrl RZG2L_GPIO(42, 0) GPIO_ACTIVE_LOW>;
+
+		ports {
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			port@1 {
+				reg = <1>;
+
+				hdmi_bridge_out: endpoint {
+					remote-endpoint = <&hdmi_con_in>;
+				};
+			};
+		};
+	};
+
+	gt911: gt911_ts@14 {
+		compatible = "goodix,gt911";
+		reg = <0x14>;
+
+		status = "disabled";
+
+		interrupt-parent = <&pinctrl>;
+		interrupts = <RZG2L_GPIO(2, 1) IRQ_TYPE_EDGE_FALLING>;
+		irq-gpios = <&pinctrl RZG2L_GPIO(2, 1) GPIO_ACTIVE_HIGH>;   /* DSI_TS_nINT */
+	};
+
+	mxt1066t2: mxt1066t2_ts@4a {
+		compatible = "atmel,maxtouch";
+		reg = <0x4a>;
+
+		status = "disabled";
+
+		interrupt-parent = <&pinctrl>;
+		interrupts = <RZG2L_GPIO(2, 1) IRQ_TYPE_EDGE_FALLING>;
+		irq-gpios = <&pinctrl RZG2L_GPIO(2, 1) GPIO_ACTIVE_HIGH>;   /* DSI_TS_nINT */
+	};
+};
+
+&i2c3 {
+	pinctrl-0 = <&i2c3_pins>;
+	pinctrl-names = "default";
+	clock-frequency = <400000>;
+	status = "okay";
+
+	versa3: versa3@68 {
+		compatible = "renesas,5p35023";
+		reg = <0x68>;
+		#clock-cells = <1>;
+		clocks = <&x1_clk>;
+		clock-names = "x1";
+		assigned-clocks = <&versa3 0>,	/* DIFF2 Audio CLK2 */
+				<&versa3 1>,	/* DIFF1 ETH1/2 CLK */
+				<&versa3 2>,	/* SE3 HDMI CLK */
+				<&versa3 3>,	/* SE2 Audio Master CLK */
+				<&versa3 4>,	/* SE1 Audio CLK1 */
+				<&versa3 5>;	/* REF RZ EXT */
+		assigned-clock-rates =	<12288000>, <25000000>,
+		                        <25000000>, <12288000>,
+		                        <11289600>, <24000000>;
+		clock-divider-read-only = <1>, <1>, <1>, <1>, <1>;
+		clock-flags = <2176>, <2176>, <2176>, <2052>, <2176>, <2048>;
+	};
+
+	pmic: raa215300@12 {
+		compatible = "renesas,raa215300";
+		reg = <0x12>;
+
+		rtc-enable;
+	};
+
+	rtc: isl1208@6f {
+		compatible = "isil,isl1208";
+		reg = <0x6f>;
+
+		external-oscillator;
+	};
+
+	da7212: codec@1a {
+		compatible = "dlg,da7212";
+		#sound-dai-cells = <0>;
+		reg = <0x1a>;
+		dlg,micbias1-lvl = <2500>;
+		dlg,micbias2-lvl = <2500>;
+		VDDA-supply = <&reg_1p8v>;
+		VDDIO-supply = <&reg_3p3v>;
+		VDDMIC-supply = <&reg_3p3v>;
+		clocks = <&audio_mclock>;
+		clock-names = "mclk";
+	};
+};
+
+&ssi0 {
+	pinctrl-0 = <&ssi0_pins>;
+	pinctrl-names = "default";
+	status = "okay";
+};
+
+&poegd {
+	status = "okay";
+};
+
+&gpt5 {
+	pinctrl-0 = <&gpt5_pins>;
+	pinctrl-names = "default";
+	channel="channel_A";
+	poeg = <&poegd>;
+	status = "disabled";
+};
+
+&dsi0 {
+	status = "disabled";
+	#address-cells = <1>;
+	#size-cells = <0>;
+
+	mipi_panel: panel@0 {
+		power-supply = <&reg_5p0v>;
+		reg = <0>;
+		backlight = <&backlight>;
+		status = "disabled";
+	};
+};
+
+&adc {
+	pinctrl-0 = <&adc_pins>;
+	pinctrl-names = "default";
+	status = "okay";
+
+	/delete-node/ channel@6;
+	/delete-node/ channel@7;
+};
+
+&canfd {
+	pinctrl-0 = <&can0_pins &can1_pins>;
+	pinctrl-names = "default";
+	status = "okay";
+	channel0 {
+		renesas,channel = <0>;
+		status = "okay";
+	};
+	channel1 {
+		renesas,channel = <1>;
+		status = "okay";
+	};
+};
+
+&sbc {
+	status = "okay";
+
+	pinctrl-0 = <&qspi0_pins>;
+	pinctrl-names = "default";
+
+	flash@0 {
+		status = "okay";
+
+		compatible = "mxicy,mx25u25645g", "jedec,spi-nor";
+		spi-max-frequency = <50000000>;
+		reg = <0>;
+		spi-rx-bus-width = <4>;
+		spi-tx-bus-width = <4>;
+		m25p,fast-read;
+
+		partitions {
+			compatible = "fixed-partitions";
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			partition@0000000 {
+				label = "u-boot";
+				reg = <0x00000000 0x1FFE000>;
+				read-only;
+			};
+			partition@0x1FFE000 {
+				label = "env";
+				reg = <0x1FFE000 0x2000>;
+				read-only;
+			};
+		};
+	};
+};
+
+
+&pinctrl {
+	pinctrl-0 = <&sound_clk_pins>;
+	pinctrl-names = "default";
+
+	sound_clk_pins: sound_clk {
+		pins = "AUDIO_CLK1", "AUDIO_CLK2";
+		input-enable;
+	};
+
+	adc_pins: adc {
+		pinmux = <RZG2L_PORT_PINMUX(9, 0, 2)>; /* ADC_TRG */
+	};
+
+	scif0_pins: scif0 {
+		pinmux = <RZG2L_PORT_PINMUX(38, 0, 1)>,	/* TxD */
+			 <RZG2L_PORT_PINMUX(38, 1, 1)>;	/* RxD */
+	};
+
+	scif1_pins: scif1 {
+		pinmux = <RZG2L_PORT_PINMUX(40, 0, 1)>, /* TxD */
+			 <RZG2L_PORT_PINMUX(40, 1, 1)>; /* RxD */
+	};
+
+	scif3_pins: scif3 {
+		pinmux = <RZG2L_PORT_PINMUX(0, 0, 5)>, /* TxD */
+			 <RZG2L_PORT_PINMUX(0, 1, 5)>; /* RxD */
+	};
+
+
+	i2c0_pins: i2c0 {
+		pins = "RIIC0_SDA", "RIIC0_SCL";
+		input-enable;
+	};
+
+	i2c1_pins: i2c1 {
+		pins = "RIIC1_SDA", "RIIC1_SCL";
+		input-enable;
+	};
+
+	i2c3_pins: i2c3 {
+		pinmux = <RZG2L_PORT_PINMUX(18, 0, 3)>, /* SDA */
+			 	 <RZG2L_PORT_PINMUX(18, 1, 3)>; /* SCL */
+	};
+
+	eth0_pins: eth0 {
+		pinmux = <RZG2L_PORT_PINMUX(28, 1, 1)>, /* ET0_LINKSTA */
+				 <RZG2L_PORT_PINMUX(27, 1, 1)>, /* ET0_MDC */
+				 <RZG2L_PORT_PINMUX(28, 0, 1)>, /* ET0_MDIO */
+				 <RZG2L_PORT_PINMUX(20, 0, 1)>, /* ET0_TXC */
+				 <RZG2L_PORT_PINMUX(20, 1, 1)>, /* ET0_TX_CTL */
+				 <RZG2L_PORT_PINMUX(20, 2, 1)>, /* ET0_TXD0 */
+				 <RZG2L_PORT_PINMUX(21, 0, 1)>, /* ET0_TXD1 */
+				 <RZG2L_PORT_PINMUX(21, 1, 1)>, /* ET0_TXD2 */
+				 <RZG2L_PORT_PINMUX(22, 0, 1)>, /* ET0_TXD3 */
+				 <RZG2L_PORT_PINMUX(24, 0, 1)>, /* ET0_RXC */
+				 <RZG2L_PORT_PINMUX(24, 1, 1)>, /* ET0_RX_CTL */
+				 <RZG2L_PORT_PINMUX(25, 0, 1)>, /* ET0_RXD0 */
+				 <RZG2L_PORT_PINMUX(25, 1, 1)>, /* ET0_RXD1 */
+				 <RZG2L_PORT_PINMUX(26, 0, 1)>, /* ET0_RXD2 */
+				 <RZG2L_PORT_PINMUX(26, 1, 1)>; /* ET0_RXD3 */
+	};
+
+	eth1_pins: eth1 {
+		pinmux = <RZG2L_PORT_PINMUX(37, 2, 1)>, /* ET1_LINKSTA */
+				 <RZG2L_PORT_PINMUX(37, 0, 1)>, /* ET1_MDC */
+				 <RZG2L_PORT_PINMUX(37, 1, 1)>, /* ET1_MDIO */
+				 <RZG2L_PORT_PINMUX(29, 0, 1)>, /* ET1_TXC */
+				 <RZG2L_PORT_PINMUX(29, 1, 1)>, /* ET1_TX_CTL */
+				 <RZG2L_PORT_PINMUX(30, 0, 1)>, /* ET1_TXD0 */
+				 <RZG2L_PORT_PINMUX(30, 1, 1)>, /* ET1_TXD1 */
+				 <RZG2L_PORT_PINMUX(31, 0, 1)>, /* ET1_TXD2 */
+				 <RZG2L_PORT_PINMUX(31, 1, 1)>, /* ET1_TXD3 */
+				 <RZG2L_PORT_PINMUX(33, 1, 1)>, /* ET1_RXC */
+				 <RZG2L_PORT_PINMUX(34, 0, 1)>, /* ET1_RX_CTL */
+				 <RZG2L_PORT_PINMUX(34, 1, 1)>, /* ET1_RXD0 */
+				 <RZG2L_PORT_PINMUX(35, 0, 1)>, /* ET1_RXD1 */
+				 <RZG2L_PORT_PINMUX(35, 1, 1)>, /* ET1_RXD2 */
+				 <RZG2L_PORT_PINMUX(36, 0, 1)>; /* ET1_RXD3 */
+	};
+
+	gpio-sd0-pwr-en-hog {
+		gpio-hog;
+		gpios = <RZG2L_GPIO(19, 0) GPIO_ACTIVE_HIGH>;
+		output-high;
+		line-name = "gpio_sd0_pwr_en";
+	};
+
+	usb0_pins: usb0 {
+		pinmux = <RZG2L_PORT_PINMUX(4, 0, 1)>, /* VBUS */
+			 <RZG2L_PORT_PINMUX(5, 0, 1)>; /* OVC */
+	};
+
+	usb1_pins: usb1 {
+		pinmux = <RZG2L_PORT_PINMUX(8, 0, 2)>, /* VBUS */
+			 <RZG2L_PORT_PINMUX(8, 1, 2)>; /* OVC */
+	};
+
+	ssi0_pins: ssi0 {
+		pinmux = <RZG2L_PORT_PINMUX(45, 0, 1)>, /* BCK */
+			 <RZG2L_PORT_PINMUX(45, 1, 1)>, /* RCK */
+			 <RZG2L_PORT_PINMUX(45, 2, 1)>, /* TXD */
+			 <RZG2L_PORT_PINMUX(45, 3, 1)>; /* RXD */
+	};
+
+	gpt5_pins: gpt5 {
+		pinmux = <RZG2L_PORT_PINMUX(43, 2, 2)>; /* Channel A */
+	};
+
+	can0_stb {
+		gpio-hog;
+		gpios = <RZG2L_GPIO(11, 1) GPIO_ACTIVE_LOW>;
+		output-high;
+		line-name = "can0_stb";
+	};
+
+	can0_pins: can0 {
+		pinmux = <RZG2L_PORT_PINMUX(10, 1, 2)>, /* TX */
+			 <RZG2L_PORT_PINMUX(11, 0, 2)>; /* RX */
+	};
+
+	can1_stb {
+		gpio-hog;
+		gpios = <RZG2L_GPIO(7, 1) GPIO_ACTIVE_LOW>;
+		output-high;
+		line-name = "can1_stb";
+	};
+
+	can1_pins: can1 {
+		pinmux = <RZG2L_PORT_PINMUX(12, 1, 2)>, /* TX */
+			 <RZG2L_PORT_PINMUX(22, 1, 3)>; /* RX */
+	};
+
+	/*
+	 * SD0 device selection is XOR between GPIO_SD0_DEV_SEL and SW1[3]
+	 * The below switch logic can be used to select the device between
+	 * eMMC and microSD, after setting GPIO_SD0_DEV_SEL to high in DT.
+	 * SW1[3] should be at position 2/OFF to enable xx GB eMMC
+	 * SW1[3] should be at position 3/ON to enable uSD card CN11
+	 */
+
+	sdhi0_emmc_pins: sd0emmc {
+		sd0_emmc_data {
+			pins = "SD0_DATA0", "SD0_DATA1", "SD0_DATA2", "SD0_DATA3",
+			       "SD0_DATA4", "SD0_DATA5", "SD0_DATA6", "SD0_DATA7";
+			power-source = <1800>;
+		};
+
+		sd0_emmc_ctrl {
+			pins = "SD0_CLK", "SD0_CMD";
+			power-source = <1800>;
+		};
+
+		sd0_emmc_rst {
+			pins = "SD0_RST#";
+			power-source = <1800>;
+		};
+	};
+
+	sdhi0_pins: sd0 {
+		sd0_data {
+			pins = "SD0_DATA0", "SD0_DATA1", "SD0_DATA2", "SD0_DATA3";
+			power-source = <3300>;
+		};
+
+		sd0_ctrl {
+			pins = "SD0_CLK", "SD0_CMD";
+			power-source = <3300>;
+		};
+
+		sd0_mux {
+			pinmux = <RZG2L_PORT_PINMUX(47, 0, 2)>; /* SD0_CD */
+		};
+	};
+
+	sdhi0_pins_uhs: sd0_uhs {
+		sd0_data_uhs {
+			pins = "SD0_DATA0", "SD0_DATA1", "SD0_DATA2", "SD0_DATA3";
+			power-source = <1800>;
+		};
+
+		sd0_ctrl_uhs {
+			pins = "SD0_CLK", "SD0_CMD";
+			power-source = <1800>;
+		};
+
+		sd0_mux_uhs {
+			pinmux = <RZG2L_PORT_PINMUX(47, 0, 2)>; /* SD0_CD */
+		};
+	};
+
+	qspi0_pins: qspi0 {
+		qspi0-data {
+			pins = "QSPI0_IO0", "QSPI0_IO1", "QSPI0_IO2", "QSPI0_IO3";
+			power-source = <1800>;
+		};
+
+		qspi0-ctrl {
+			pins = "QSPI0_SPCLK", "QSPI0_SSL", "QSPI_RESET#";
+			power-source = <1800>;
+		};
+	};
+};
+
diff --git a/arch/arm64/configs/vkrzv2l_defconfig b/arch/arm64/configs/vkrzv2l_defconfig
new file mode 100644
index 000000000000..de780f3d01dc
--- /dev/null
+++ b/arch/arm64/configs/vkrzv2l_defconfig
@@ -0,0 +1,505 @@
+CONFIG_SPI_SLAVE=y
+CONFIG_SPI_RSPI=y
+CONFIG_LOCALVERSION="-arm64-renesas"
+CONFIG_SYSVIPC=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_AUDIT=y
+CONFIG_NO_HZ_IDLE=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_PREEMPT=y
+CONFIG_IRQ_TIME_ACCOUNTING=y
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+CONFIG_TASKSTATS=y
+CONFIG_TASK_DELAY_ACCT=y
+CONFIG_TASK_XACCT=y
+CONFIG_TASK_IO_ACCOUNTING=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_MEMCG=y
+CONFIG_MEMCG_SWAP=y
+CONFIG_BLK_CGROUP=y
+CONFIG_CGROUP_PIDS=y
+CONFIG_CGROUP_HUGETLB=y
+CONFIG_CPUSETS=y
+CONFIG_CGROUP_DEVICE=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_CGROUP_PERF=y
+CONFIG_USER_NS=y
+CONFIG_SCHED_AUTOGROUP=y
+CONFIG_BLK_DEV_INITRD=y
+# CONFIG_COMPAT_BRK is not set
+CONFIG_PROFILING=y
+CONFIG_ARCH_RENESAS=y
+# CONFIG_CAVIUM_ERRATUM_22375 is not set
+# CONFIG_CAVIUM_ERRATUM_23154 is not set
+# CONFIG_CAVIUM_ERRATUM_27456 is not set
+# CONFIG_CAVIUM_ERRATUM_30115 is not set
+# CONFIG_QCOM_FALKOR_ERRATUM_1003 is not set
+# CONFIG_QCOM_FALKOR_ERRATUM_1009 is not set
+# CONFIG_QCOM_QDF2400_ERRATUM_0065 is not set
+# CONFIG_SOCIONEXT_SYNQUACER_PREITS is not set
+# CONFIG_HISILICON_ERRATUM_161600802 is not set
+CONFIG_ARM64_VA_BITS_48=y
+CONFIG_SCHED_MC=y
+CONFIG_NR_CPUS=8
+CONFIG_SECCOMP=y
+CONFIG_KEXEC=y
+CONFIG_CRASH_DUMP=y
+CONFIG_XEN=y
+# CONFIG_ARM64_LSE_ATOMICS is not set
+# CONFIG_ARM64_RAS_EXTN is not set
+CONFIG_COMPAT=y
+CONFIG_HIBERNATION=y
+CONFIG_WQ_POWER_EFFICIENT_DEFAULT=y
+CONFIG_ARM_CPUIDLE=y
+CONFIG_ARM_PSCI_CPUIDLE=y
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_STAT=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_CPU_FREQ_GOV_SCHEDUTIL=y
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPUFREQ_DT=y
+# CONFIG_DMIID is not set
+CONFIG_VIRTUALIZATION=y
+CONFIG_KVM=y
+CONFIG_ARM64_CRYPTO=y
+CONFIG_CRYPTO_SHA1_ARM64_CE=y
+CONFIG_CRYPTO_SHA2_ARM64_CE=y
+CONFIG_CRYPTO_GHASH_ARM64_CE=y
+CONFIG_CRYPTO_AES_ARM64_CE_CCM=y
+CONFIG_CRYPTO_AES_ARM64_CE_BLK=y
+CONFIG_JUMP_LABEL=y
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_BLK_DEV_INTEGRITY=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_KSM=y
+CONFIG_TRANSPARENT_HUGEPAGE=y
+CONFIG_CMA=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_NETFILTER=y
+CONFIG_CAN=y
+CONFIG_CAN_RCAR=y
+CONFIG_CAN_RCAR_CANFD=y
+CONFIG_PCI=y
+CONFIG_PCIEPORTBUS=y
+CONFIG_PCI_IOV=y
+CONFIG_HOTPLUG_PCI=y
+CONFIG_PCIE_RCAR_HOST=y
+CONFIG_PCIE_RCAR_EP=y
+CONFIG_PCI_HOST_GENERIC=y
+CONFIG_PCI_ENDPOINT=y
+CONFIG_PCI_ENDPOINT_CONFIGFS=y
+CONFIG_PCI_EPF_TEST=y
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_SIMPLE_PM_BUS=y
+CONFIG_MTD=y
+CONFIG_MTD_BLOCK=y
+CONFIG_MTD_SPI_NOR=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_VIRTIO_BLK=y
+CONFIG_SRAM=y
+CONFIG_PCI_ENDPOINT_TEST=y
+# CONFIG_SCSI_PROC_FS is not set
+CONFIG_BLK_DEV_SD=y
+CONFIG_ATA=y
+CONFIG_SATA_RCAR=y
+# CONFIG_SATA_PMP is not set
+CONFIG_NETDEVICES=y
+CONFIG_TUN=y
+CONFIG_VIRTIO_NET=y
+CONFIG_RAVB=y
+# CONFIG_CAVIUM_PTP is not set
+CONFIG_MDIO_BUS_MUX_MMIOREG=y
+CONFIG_MICREL_PHY=y
+CONFIG_REALTEK_PHY=y
+# CONFIG_WLAN is not set
+CONFIG_INPUT_MATRIXKMAP=y
+CONFIG_INPUT_EVDEV=y
+CONFIG_KEYBOARD_GPIO=y
+# CONFIG_KEYBOARD_ATKBD is not set
+CONFIG_KEYBOARD_CROS_EC=y
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_USB_COMPOSITE=y
+CONFIG_INPUT_HISI_POWERKEY=y
+CONFIG_SERIAL_SH_SCI=y
+CONFIG_INPUT_UINPUT=m
+CONFIG_INPUT_MOUSEDEV=m
+# CONFIG_MOUSE_PS2 is not set
+CONFIG_INPUT_MISC=y
+CONFIG_VIRTIO_CONSOLE=y
+# CONFIG_HW_RANDOM is not set
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_MUX=y
+CONFIG_I2C_MUX_PCA954x=y
+CONFIG_I2C_DESIGNWARE_PLATFORM=y
+CONFIG_I2C_RIIC=y
+CONFIG_I2C_SH_MOBILE=y
+CONFIG_I2C_RCAR=y
+CONFIG_SPI=y
+CONFIG_SPI_RPCIF=y
+CONFIG_SPI_SH_MSIOF=y
+CONFIG_SPI_SPIDEV=y
+CONFIG_SPMI=y
+CONFIG_PINCTRL_SINGLE=y
+CONFIG_GPIO_GENERIC_PLATFORM=y
+CONFIG_GPIO_RCAR=y
+CONFIG_GPIO_PCA953X=y
+CONFIG_GPIO_PCA953X_IRQ=y
+CONFIG_GPIO_BD9571MWV=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_THERMAL=y
+CONFIG_THERMAL_GOV_POWER_ALLOCATOR=y
+CONFIG_CPU_THERMAL=y
+CONFIG_THERMAL_EMULATION=y
+CONFIG_RCAR_THERMAL=y
+CONFIG_RCAR_GEN3_THERMAL=y
+CONFIG_RZG2L_THERMAL=y
+CONFIG_RCAR_THERMAL_EMS_ENABLED=y
+CONFIG_WATCHDOG=y
+CONFIG_RENESAS_WDT=y
+CONFIG_RENESAS_RZG2LWDT=y
+CONFIG_UNIPHIER_WATCHDOG=y
+CONFIG_BCM2835_WDT=y
+CONFIG_MFD_BD9571MWV=y
+CONFIG_REGULATOR=y
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+CONFIG_REGULATOR_BD9571MWV=y
+CONFIG_REGULATOR_GPIO=y
+CONFIG_REGULATOR_PWM=y
+CONFIG_MEDIA_SUPPORT=y
+CONFIG_MEDIA_CAMERA_SUPPORT=y
+CONFIG_MEDIA_SDR_SUPPORT=y
+CONFIG_MEDIA_CONTROLLER=y
+CONFIG_MEDIA_PLATFORM_SUPPORT=y
+CONFIG_VIDEO_OV5645=y
+CONFIG_VIDEO_IMX219=y
+CONFIG_VIDEO_V4L2_SUBDEV_API=y
+CONFIG_V4L_PLATFORM_DRIVERS=y
+CONFIG_VIDEO_RCAR_CSI2=y
+CONFIG_VIDEO_RCAR_VIN=y
+CONFIG_VIDEO_RZG2L_CRU=y
+CONFIG_VIDEO_RZG2L_CSI2=y
+CONFIG_V4L_MEM2MEM_DRIVERS=y
+CONFIG_MEDIA_USB_SUPPORT=y
+CONFIG_USB_VIDEO_CLASS=m
+CONFIG_VIDEO_RENESAS_FDP1=y
+CONFIG_VIDEO_RENESAS_FCP=y
+CONFIG_VIDEO_RENESAS_VSP1=y
+CONFIG_SDR_PLATFORM_DRIVERS=y
+CONFIG_VIDEO_RCAR_DRIF=y
+# CONFIG_MEDIA_SUBDRV_AUTOSELECT is not set
+CONFIG_VIDEO_ADV748X=y
+# CONFIG_MEDIA_TUNER_SIMPLE is not set
+# CONFIG_MEDIA_TUNER_TDA18250 is not set
+# CONFIG_MEDIA_TUNER_TDA8290 is not set
+# CONFIG_MEDIA_TUNER_TDA827X is not set
+# CONFIG_MEDIA_TUNER_TDA18271 is not set
+# CONFIG_MEDIA_TUNER_TDA9887 is not set
+# CONFIG_MEDIA_TUNER_TEA5761 is not set
+# CONFIG_MEDIA_TUNER_TEA5767 is not set
+# CONFIG_MEDIA_TUNER_MSI001 is not set
+# CONFIG_MEDIA_TUNER_MT20XX is not set
+# CONFIG_MEDIA_TUNER_MT2060 is not set
+# CONFIG_MEDIA_TUNER_MT2063 is not set
+# CONFIG_MEDIA_TUNER_MT2266 is not set
+# CONFIG_MEDIA_TUNER_MT2131 is not set
+# CONFIG_MEDIA_TUNER_QT1010 is not set
+# CONFIG_MEDIA_TUNER_XC2028 is not set
+# CONFIG_MEDIA_TUNER_XC5000 is not set
+# CONFIG_MEDIA_TUNER_XC4000 is not set
+# CONFIG_MEDIA_TUNER_MXL5005S is not set
+# CONFIG_MEDIA_TUNER_MXL5007T is not set
+# CONFIG_MEDIA_TUNER_MC44S803 is not set
+# CONFIG_MEDIA_TUNER_MAX2165 is not set
+# CONFIG_MEDIA_TUNER_TDA18218 is not set
+# CONFIG_MEDIA_TUNER_FC0011 is not set
+# CONFIG_MEDIA_TUNER_FC0012 is not set
+# CONFIG_MEDIA_TUNER_FC0013 is not set
+# CONFIG_MEDIA_TUNER_TDA18212 is not set
+# CONFIG_MEDIA_TUNER_E4000 is not set
+# CONFIG_MEDIA_TUNER_FC2580 is not set
+# CONFIG_MEDIA_TUNER_M88RS6000T is not set
+# CONFIG_MEDIA_TUNER_TUA9001 is not set
+# CONFIG_MEDIA_TUNER_SI2157 is not set
+# CONFIG_MEDIA_TUNER_IT913X is not set
+# CONFIG_MEDIA_TUNER_R820T is not set
+# CONFIG_MEDIA_TUNER_MXL301RF is not set
+# CONFIG_MEDIA_TUNER_QM1D1C0042 is not set
+# CONFIG_MEDIA_TUNER_QM1D1B0004 is not set
+CONFIG_DRM=y
+CONFIG_DRM_I2C_NXP_TDA998X=y
+CONFIG_DRM_RCAR_DU=y
+CONFIG_DRM_RCAR_DW_HDMI=y
+CONFIG_DRM_RZG2L_MIPI_DSI=y
+CONFIG_DRM_PANEL_LVDS=y
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_DRM_DUMB_VGA_DAC=y
+CONFIG_DRM_THINE_THC63LVD1024=y
+CONFIG_DRM_I2C_ADV7511=y
+CONFIG_DRM_I2C_ADV7511_AUDIO=y
+CONFIG_DRM_DW_HDMI_AHB_AUDIO=y
+CONFIG_DRM_DW_HDMI_I2S_AUDIO=y
+CONFIG_DRM_DW_HDMI_CEC=y
+CONFIG_FB_MODE_HELPERS=y
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+CONFIG_BACKLIGHT_GENERIC=y
+CONFIG_BACKLIGHT_PWM=y
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+CONFIG_SOUND=y
+CONFIG_SND=y
+# CONFIG_SND_SPI is not set
+# CONFIG_SND_USB is not set
+CONFIG_SND_SOC=y
+CONFIG_SND_SOC_RCAR=y
+CONFIG_SND_SOC_RZ=y
+CONFIG_SND_SOC_WM8978=y
+CONFIG_SND_SOC_PCM5102A=y
+CONFIG_SND_SIMPLE_CARD=y
+CONFIG_SND_SIMPLE_SCU_CARD=y
+CONFIG_SND_AUDIO_GRAPH_CARD=y
+CONFIG_USB=y
+CONFIG_USB_OTG=y
+CONFIG_USB_XHCI_HCD=y
+CONFIG_USB_XHCI_PLATFORM=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+CONFIG_USB_EHCI_HCD_PLATFORM=y
+CONFIG_USB_OHCI_HCD=y
+CONFIG_USB_OHCI_HCD_PLATFORM=y
+CONFIG_USB_RENESAS_USBHS_HCD=y
+CONFIG_USB_RENESAS_USBHS=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_ULPI=y
+CONFIG_USB_HSIC_USB3503=y
+CONFIG_NOP_USB_XCEIV=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_RENESAS_USBHS_UDC=y
+CONFIG_USB_RENESAS_USB3=y
+CONFIG_USB_SNP_UDC_PLAT=y
+CONFIG_USB_BDC_UDC=y
+CONFIG_TYPEC=y
+CONFIG_TYPEC_HD3SS3220=y
+CONFIG_USB_MASS_STORAGE=m
+CONFIG_USB_G_SERIAL=m
+CONFIG_USB_ETH=m
+CONFIG_MMC=y
+CONFIG_MMC_SDHI=y
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+CONFIG_LEDS_GPIO=y
+CONFIG_LEDS_PWM=y
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+CONFIG_LEDS_TRIGGER_CPU=y
+CONFIG_LEDS_TRIGGER_DEFAULT_ON=y
+CONFIG_LEDS_TRIGGERS=y
+CONFIG_EDAC=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_RX8581=y
+CONFIG_DMADEVICES=y
+CONFIG_RCAR_DMAC=y
+CONFIG_RENESAS_USB_DMAC=y
+CONFIG_RZ_DMAC=y
+CONFIG_VFIO=y
+CONFIG_VFIO_PCI=y
+CONFIG_VIRTIO_PCI=y
+CONFIG_VIRTIO_BALLOON=y
+CONFIG_VIRTIO_MMIO=y
+CONFIG_CHROME_PLATFORMS=y
+CONFIG_COMMON_CLK_CS2000_CP=y
+CONFIG_COMMON_CLK_PWM=y
+CONFIG_COMMON_CLK_VC3=y
+CONFIG_COMMON_CLK_VC5=y
+# CONFIG_COMMON_CLK_XGENE is not set
+CONFIG_CLK_RCAR_USB2_CLOCK_SEL=y
+CONFIG_HWSPINLOCK=y
+CONFIG_ARCH_R8A774A1=y
+CONFIG_ARCH_R8A774A3=y
+CONFIG_ARCH_R8A774B1=y
+CONFIG_ARCH_R8A774C0=y
+CONFIG_ARCH_R8A774E1=y
+CONFIG_ARCH_R9A07G054=y
+CONFIG_ARCH_R9A07G044=y
+CONFIG_ARCH_R9A07G043=y
+# CONFIG_FSL_ERRATUM_A008585 is not set
+# CONFIG_HISILICON_ERRATUM_161010101 is not set
+# CONFIG_ARM64_ERRATUM_858921 is not set
+CONFIG_MAILBOX=y
+CONFIG_IOMMU_IO_PGTABLE_LPAE=y
+CONFIG_IPMMU_VMSA=y
+CONFIG_EXTCON_USB_GPIO=y
+CONFIG_MEMORY=y
+CONFIG_RENESAS_RPCIF=y
+CONFIG_IIO=y
+CONFIG_RZG2L_ADC=y
+CONFIG_MAX9611=y
+CONFIG_PWM=y
+CONFIG_PWM_RCAR=y
+CONFIG_PWM_RENESAS_TPU=y
+CONFIG_GPT_RZG2L=y
+CONFIG_POEG_RZG2L=y
+CONFIG_RESET_CONTROLLER=y
+CONFIG_RESET_RZG2L_USBPHY_CTRL=y
+CONFIG_PHY_RCAR_GEN3_PCIE=y
+CONFIG_PHY_RCAR_GEN3_USB2=y
+CONFIG_PHY_RCAR_GEN3_USB3=y
+CONFIG_TEE=y
+CONFIG_OPTEE=y
+CONFIG_JFFS2_FS=y
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_FANOTIFY=y
+CONFIG_QUOTA=y
+CONFIG_AUTOFS4_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_TMPFS=y
+CONFIG_HUGETLBFS=y
+CONFIG_CONFIGFS_FS=y
+CONFIG_SQUASHFS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V4=y
+CONFIG_NFS_V4_1=y
+CONFIG_NFS_V4_2=y
+CONFIG_ROOT_NFS=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_CRYPTO_ANSI_CPRNG=y
+CONFIG_DMA_CMA=y
+CONFIG_CMA_SIZE_MBYTES=128
+# CONFIG_CRYPTO_DEV_VIRTIO is not set
+CONFIG_CRYPTO_DEV_CCREE=y
+CONFIG_CMA_ALIGNMENT=9
+CONFIG_PRINTK_TIME=y
+CONFIG_DEBUG_FS=y
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_DEBUG_PREEMPT is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_FTRACE is not set
+CONFIG_PM_DEVFREQ=y
+CONFIG_DEVFREQ_GOV_SIMPLE_ONDEMAND=y
+CONFIG_DEVFREQ_GOV_PERFORMANCE=y
+CONFIG_DEVFREQ_GOV_POWERSAVE=y
+CONFIG_DEVFREQ_GOV_USERSPACE=y
+CONFIG_DEVFREQ_GOV_PASSIVE=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE=y
+CONFIG_E1000E=y
+CONFIG_RENESAS_MFIS_ECC=y
+CONFIG_VIDEOBUF2_DMA_CONTIG=m
+CONFIG_RENESAS_TIMER_MTU3=y
+CONFIG_RENESAS_POE3=y
+CONFIG_RENESAS_OSTM=y
+CONFIG_PMIC_RAA215300=y
+CONFIG_RTC_DRV_ISL1208=y
+#
+#
+# CANbus support
+#
+#CONFIG_CAN=y
+CONFIG_CAN_RAW=y
+CONFIG_CAN_BCM=y
+CONFIG_CAN_GW=y
+CONFIG_CAN_VCAN=m
+CONFIG_CAN_VXCAN=m
+CONFIG_CAN_DEV=y
+CONFIG_CAN_CALC_BITTIMING=y
+#CONFIG_CAN_RCAR=y
+#CONFIG_CAN_RCAR_CANFD=y
+CONFIG_CAN_DEBUG_DEVICES=y
+#
+# Additional kernel config items needed for iproute2 and SocketCAN
+#
+CONFIG_NETFILTER_NETLINK=y
+CONFIG_NETFILTER_NETLINK_QUEUE=y
+CONFIG_NETFILTER_NETLINK_LOG=y
+CONFIG_NF_CT_NETLINK=y
+CONFIG_SCSI_NETLINK=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_NET_SCH_INGRESS=y
+CONFIG_NET_SCHED=y
+CONFIG_CC_CAN_LINK=y
+CONFIG_CC_CAN_LINK_STATIC=y
+#
+CONFIG_TOUCHSCREEN_GOODIX=m
+#
+CONFIG_DRM_LONTIUM_LT8912B=y
+CONFIG_DRM_DISPLAY_CONNECTOR=y
+#
+CONFIG_BRIDGE_NETFILTER=m
+CONFIG_NETFILTER_FAMILY_BRIDGE=y
+CONFIG_NF_CONNTRACK=m
+CONFIG_NF_NAT=m
+CONFIG_NETFILTER_XT_NAT=m
+CONFIG_NETFILTER_XT_TARGET_MASQUERADE=m
+#
+# IP: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV4=m
+CONFIG_NF_SOCKET_IPV4=m
+CONFIG_IP_NF_IPTABLES=m
+CONFIG_IP_NF_FILTER=m
+CONFIG_IP_NF_NAT=m
+CONFIG_IP_NF_TARGET_MASQUERADE=m
+#
+# IPv6: Netfilter Configuration
+#
+CONFIG_NF_SOCKET_IPV6=m
+CONFIG_IP6_NF_IPTABLES=m
+CONFIG_IP6_NF_FILTER=m
+CONFIG_IP6_NF_NAT=m
+CONFIG_IP6_NF_TARGET_MASQUERADE=m
+CONFIG_NF_DEFRAG_IPV6=m
+
+CONFIG_STP=y
+CONFIG_GARP=y
+CONFIG_MRP=y
+CONFIG_BRIDGE=m
+CONFIG_BRIDGE_IGMP_SNOOPING=y
+CONFIG_BRIDGE_VLAN_FILTERING=y
+CONFIG_SKB_EXTENSIONS=y
+#
+CONFIG_DRM_PANEL_ILITEK_ILI9881C=y
+#
+CONFIG_DRM_PANEL_FITIPOWER_EK79007AD=y
+#
+#CONFIG_REALTEK_PHY=y
+#
+CONFIG_SND_SOC_DA7213=y
+#
+CONFIG_UDMABUF=yes
+#
+CONFIG_USB_STORAGE_DEBUG=y
+CONFIG_USB_GADGET_DEBUG=y
+CONFIG_USB_GADGET_VERBOSE=y
+CONFIG_USB_GADGET_DEBUG_FILES=y
+CONFIG_USB_ACM=m
+CONFIG_USB_TMC=m
+CONFIG_USB_SERIAL=m
+CONFIG_USB_SERIAL_GENERIC=y
+CONFIG_USB_SERIAL_SIMPLE=m
+CONFIG_USB_SERIAL_CP210X=m
+CONFIG_USB_SERIAL_FTDI_SIO=m
+CONFIG_USB_SERIAL_PL2303=m
+#
+CONFIG_TOUCHSCREEN_ATMEL_MXT=m
+#
+# DRP-AI/DRP support
+#
+CONFIG_DRPAI=y
+# end of DRP-AI/DRP support
+# end of Device Drivers
diff --git a/drivers/gpu/drm/bridge/Kconfig b/drivers/gpu/drm/bridge/Kconfig
index 4e82647a621e..e8675c721f4f 100644
--- a/drivers/gpu/drm/bridge/Kconfig
+++ b/drivers/gpu/drm/bridge/Kconfig
@@ -48,6 +48,22 @@ config DRM_DISPLAY_CONNECTOR
 	  on ARM-based platforms. Saying Y here when this driver is not needed
 	  will not cause any issue.

+config DRM_LONTIUM_LT8912B
+	tristate "Lontium LT8912B DSI/HDMI bridge"
+	depends on OF
+	select DRM_PANEL_BRIDGE
+	select DRM_KMS_HELPER
+	select DRM_MIPI_DSI
+	select REGMAP_I2C
+	select VIDEOMODE_HELPERS
+	help
+	  Driver for Lontium LT8912B DSI to HDMI bridge
+	  chip driver.
+	  Please say Y if you have such hardware.
+
+	  Say M here if you want to support this hardware as a module.
+	  The module will be named "lontium-lt8912b".
+
 config DRM_LONTIUM_LT9611
 	tristate "Lontium LT9611 DSI/HDMI bridge"
 	select SND_SOC_HDMI_CODEC if SND_SOC
diff --git a/drivers/gpu/drm/bridge/Makefile b/drivers/gpu/drm/bridge/Makefile
index 2b3aff104e46..e6adca817458 100644
--- a/drivers/gpu/drm/bridge/Makefile
+++ b/drivers/gpu/drm/bridge/Makefile
@@ -2,6 +2,7 @@
 obj-$(CONFIG_DRM_CDNS_DSI) += cdns-dsi.o
 obj-$(CONFIG_DRM_CHRONTEL_CH7033) += chrontel-ch7033.o
 obj-$(CONFIG_DRM_DISPLAY_CONNECTOR) += display-connector.o
+obj-$(CONFIG_DRM_LONTIUM_LT8912B) += lontium-lt8912b.o
 obj-$(CONFIG_DRM_LONTIUM_LT9611) += lontium-lt9611.o
 obj-$(CONFIG_DRM_LVDS_CODEC) += lvds-codec.o
 obj-$(CONFIG_DRM_MEGACHIPS_STDPXXXX_GE_B850V3_FW) += megachips-stdpxxxx-ge-b850v3-fw.o
diff --git a/drivers/gpu/drm/bridge/lontium-lt8912b.c b/drivers/gpu/drm/bridge/lontium-lt8912b.c
new file mode 100644
index 000000000000..be29679e94f6
--- /dev/null
+++ b/drivers/gpu/drm/bridge/lontium-lt8912b.c
@@ -0,0 +1,845 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2018, The Linux Foundation. All rights reserved.
+ */
+//#define DEBUG
+
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/i2c.h>
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
+#include <linux/regmap.h>
+
+#include <drm/drm_probe_helper.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_of.h>
+
+#include <video/videomode.h>
+
+#define I2C_MAIN 0
+#define I2C_ADDR_MAIN 0x48
+
+#define I2C_CEC_DSI 1
+#define I2C_ADDR_CEC_DSI 0x49
+
+#define I2C_MAX_IDX 2
+
+struct lt8912 {
+	struct device *dev;
+	struct drm_bridge bridge;
+	struct drm_connector connector;
+
+	struct i2c_client *i2c_client[I2C_MAX_IDX];
+	struct regmap *regmap[I2C_MAX_IDX];
+
+	struct device_node *host_node;
+	struct drm_bridge *hdmi_port;
+
+	struct mipi_dsi_device *dsi;
+
+	struct gpio_desc *gp_reset;
+
+	struct videomode mode;
+
+	u8 data_lanes;
+	bool is_power_on;
+	bool is_attached;
+};
+
+static int lt8912_write_init_config(struct lt8912 *lt)
+{
+	const struct reg_sequence seq[] = {
+		/* Digital clock en*/
+		{0x08, 0xff},
+		{0x09, 0xff},
+		{0x0a, 0xff},
+		{0x0b, 0x7c},
+		{0x0c, 0xff},
+		{0x42, 0x04},
+
+		/*Tx Analog*/
+		{0x31, 0xb1},
+		{0x32, 0xb1},
+		{0x33, 0x0e},
+		{0x37, 0x00},
+		{0x38, 0x22},
+		{0x60, 0x82},
+
+		/*Cbus Analog*/
+		{0x39, 0x45},
+		{0x3a, 0x00},
+		{0x3b, 0x00},
+
+		/*HDMI Pll Analog*/
+		{0x44, 0x31},
+		{0x55, 0x44},
+		{0x57, 0x01},
+		{0x5a, 0x02},
+
+		/*MIPI Analog*/
+		{0x3e, 0xd6},
+		{0x3f, 0xd4},
+		{0x41, 0x3c},
+		{0xB2, 0x00},
+	};
+	return regmap_multi_reg_write(lt->regmap[I2C_MAIN], seq, ARRAY_SIZE(seq));
+}
+
+static int lt8912_write_mipi_basic_config(struct lt8912 *lt)
+{
+	const struct reg_sequence seq[] = {
+		{0x12, 0x04},
+		{0x14, 0x00},
+		{0x15, 0x00},
+		{0x1a, 0x03},
+		{0x1b, 0x03},
+	};
+
+	return regmap_multi_reg_write(lt->regmap[I2C_CEC_DSI], seq, ARRAY_SIZE(seq));
+};
+
+static int lt8912_write_dds_config(struct lt8912 *lt)
+{
+	const struct reg_sequence seq[] = {
+		{0x4e, 0xff},
+		{0x4f, 0x56},
+		{0x50, 0x69},
+		{0x51, 0x80},
+		{0x1f, 0x5e},
+		{0x20, 0x01},
+		{0x21, 0x2c},
+		{0x22, 0x01},
+		{0x23, 0xfa},
+		{0x24, 0x00},
+		{0x25, 0xc8},
+		{0x26, 0x00},
+		{0x27, 0x5e},
+		{0x28, 0x01},
+		{0x29, 0x2c},
+		{0x2a, 0x01},
+		{0x2b, 0xfa},
+		{0x2c, 0x00},
+		{0x2d, 0xc8},
+		{0x2e, 0x00},
+		{0x42, 0x64},
+		{0x43, 0x00},
+		{0x44, 0x04},
+		{0x45, 0x00},
+		{0x46, 0x59},
+		{0x47, 0x00},
+		{0x48, 0xf2},
+		{0x49, 0x06},
+		{0x4a, 0x00},
+		{0x4b, 0x72},
+		{0x4c, 0x45},
+		{0x4d, 0x00},
+		{0x52, 0x08},
+		{0x53, 0x00},
+		{0x54, 0xb2},
+		{0x55, 0x00},
+		{0x56, 0xe4},
+		{0x57, 0x0d},
+		{0x58, 0x00},
+		{0x59, 0xe4},
+		{0x5a, 0x8a},
+		{0x5b, 0x00},
+		{0x5c, 0x34},
+		{0x1e, 0x4f},
+		{0x51, 0x00},
+	};
+
+	return regmap_multi_reg_write(lt->regmap[I2C_CEC_DSI], seq, ARRAY_SIZE(seq));
+}
+
+static const u8 edid_data[] = {
+0x00,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x22,0x0e,0x75,0x34,0x01,0x01,0x01,0x01,
+0x13,0x1c,0x01,0x03,0x80,0x3c,0x22,0x78,0x2a,0x93,0x25,0xa9,0x54,0x4d,0x9e,0x25,
+0x0c,0x50,0x54,0xa1,0x08,0x00,0xd1,0xc0,0x81,0xc0,0x81,0x80,0x95,0x00,0xa9,0xc0,
+0xa9,0x40,0xb3,0x00,0xd1,0x00,0x56,0x5e,0x00,0xa0,0xa0,0xa0,0x29,0x50,0x30,0x20,
+0x35,0x00,0x55,0x50,0x21,0x00,0x00,0x1a,0x00,0x00,0x00,0xfd,0x00,0x32,0x3c,0x1e,
+0x5a,0x19,0x00,0x0a,0x20,0x20,0x20,0x20,0x20,0x20,0x00,0x00,0x00,0xfc,0x00,0x48,
+0x50,0x20,0x45,0x32,0x37,0x33,0x71,0x0a,0x20,0x20,0x20,0x20,0x00,0x00,0x00,0xff,
+0x00,0x36,0x43,0x4d,0x38,0x31,0x39,0x33,0x37,0x47,0x32,0x0a,0x20,0x20,0x01,0xbd,
+0x02,0x03,0x19,0xb1,0x49,0x10,0x1f,0x04,0x13,0x03,0x12,0x02,0x11,0x01,0x67,0x03,
+0x0c,0x00,0x10,0x00,0x00,0x32,0xe2,0x00,0x2b,0x02,0x3a,0x80,0x18,0x71,0x38,0x2d,
+0x40,0x58,0x2c,0x45,0x00,0x55,0x50,0x21,0x00,0x00,0x1e,0x02,0x3a,0x80,0xd0,0x72,
+0x38,0x2d,0x40,0x10,0x2c,0x45,0x80,0x55,0x50,0x21,0x00,0x00,0x1e,0x56,0x5e,0x00,
+0xa0,0xa0,0xa0,0x29,0x50,0x30,0x20,0x35,0x00,0x55,0x50,0x21,0x00,0x00,0x1a,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x23
+};
+
+static int lt8912_write_rxlogicres_config(struct lt8912 *lt)
+{
+	int ret;
+
+	ret = regmap_write(lt->regmap[I2C_MAIN], 0x03, 0x7f);
+	usleep_range(10000, 20000);
+	ret |= regmap_write(lt->regmap[I2C_MAIN], 0x03, 0xff);
+
+	return ret;
+};
+
+static int lt8912_write_lvds_config(struct lt8912 *lt)
+{
+	const struct reg_sequence seq[] = {
+		{0x44, 0x30},
+		{0x51, 0x05},
+		{0x50, 0x24},
+		{0x51, 0x2d},
+		{0x52, 0x04},
+		{0x69, 0x0e},
+		{0x69, 0x8e},
+		{0x6a, 0x00},
+		{0x6c, 0xb8},
+		{0x6b, 0x51},
+		{0x04, 0xfb},
+		{0x04, 0xff},
+		{0x7f, 0x00},
+		{0xa8, 0x13},
+		{0x02, 0xf7},
+		{0x02, 0xff},
+		{0x03, 0xcf},
+		{0x03, 0xff},
+	};
+
+	return regmap_multi_reg_write(lt->regmap[I2C_CEC_DSI], seq, ARRAY_SIZE(seq));
+};
+
+static inline struct lt8912 *bridge_to_lt8912(struct drm_bridge *b)
+{
+	return container_of(b, struct lt8912, bridge);
+}
+
+static inline struct lt8912 *connector_to_lt8912(struct drm_connector *c)
+{
+	return container_of(c, struct lt8912, connector);
+}
+
+static const struct regmap_config lt8912_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 8,
+	.max_register = 0xff,
+};
+
+static int lt8912_init_i2c(struct lt8912 *lt, struct i2c_client *client)
+{
+	unsigned int i;
+	/*
+	 * At this time we only initialize 2 chips, but the lt8912 provides
+	 * a third interface for the audio over HDMI configuration.
+	 */
+	struct i2c_board_info info[] = {
+		{ I2C_BOARD_INFO("lt8912p0", I2C_ADDR_MAIN), },
+		{ I2C_BOARD_INFO("lt8912p1", I2C_ADDR_CEC_DSI), },
+	};
+
+	if (!lt)
+		return -ENODEV;
+
+	for (i = 0; i < ARRAY_SIZE(info); i++) {
+		if (i > 0) {
+			lt->i2c_client[i] = i2c_new_dummy_device(client->adapter,
+								 info[i].addr);
+			if (IS_ERR(lt->i2c_client[i]))
+				return PTR_ERR(lt->i2c_client[i]);
+		}
+
+		lt->regmap[i] = devm_regmap_init_i2c(lt->i2c_client[i],
+						     &lt8912_regmap_config);
+		if (IS_ERR(lt->regmap[i]))
+			return PTR_ERR(lt->regmap[i]);
+	}
+	return 0;
+}
+
+static int lt8912_free_i2c(struct lt8912 *lt)
+{
+	unsigned int i;
+
+	for (i = 1; i < I2C_MAX_IDX; i++)
+		i2c_unregister_device(lt->i2c_client[i]);
+
+	return 0;
+}
+
+static int lt8912_hard_power_on(struct lt8912 *lt)
+{
+	gpiod_set_value_cansleep(lt->gp_reset, 1);
+	msleep(150);
+	gpiod_set_value_cansleep(lt->gp_reset, 0);
+	msleep(150);
+
+	return 0;
+}
+
+static void lt8912_hard_power_off(struct lt8912 *lt)
+{
+	gpiod_set_value_cansleep(lt->gp_reset, 1);
+	msleep(150);
+	lt->is_power_on = false;
+}
+
+static int lt8912_video_setup(struct lt8912 *lt)
+{
+	u32 hactive, h_total, hpw, hfp, hbp;
+	u32 vactive, v_total, vpw, vfp, vbp;
+	u8 settle = 0x08;
+	int ret;
+
+	if (!lt)
+		return -EINVAL;
+
+	hactive = lt->mode.hactive;
+	hfp = lt->mode.hfront_porch;
+	hpw = lt->mode.hsync_len;
+	hbp = lt->mode.hback_porch;
+	h_total = hactive + hfp + hpw + hbp;
+
+	vactive = lt->mode.vactive;
+	vfp = lt->mode.vfront_porch;
+	vpw = lt->mode.vsync_len;
+	vbp = lt->mode.vback_porch;
+	v_total = vactive + vfp + vpw + vbp;
+
+	if (vactive <= 600)
+		settle = 0x04;
+	else if (vactive == 1080)
+		settle = 0x0a;
+
+	ret  = regmap_write(lt->regmap[I2C_CEC_DSI], 0x10, 0x01);
+	ret |= regmap_write(lt->regmap[I2C_CEC_DSI], 0x11, settle);
+	ret |= regmap_write(lt->regmap[I2C_CEC_DSI], 0x18, hpw);
+	ret |= regmap_write(lt->regmap[I2C_CEC_DSI], 0x19, vpw);
+	ret |= regmap_write(lt->regmap[I2C_CEC_DSI], 0x1c, hactive & 0xff);
+	ret |= regmap_write(lt->regmap[I2C_CEC_DSI], 0x1d, hactive >> 8);
+
+	ret |= regmap_write(lt->regmap[I2C_CEC_DSI], 0x2f, 0x0c);
+
+	ret |= regmap_write(lt->regmap[I2C_CEC_DSI], 0x34, h_total & 0xff);
+	ret |= regmap_write(lt->regmap[I2C_CEC_DSI], 0x35, h_total >> 8);
+
+	ret |= regmap_write(lt->regmap[I2C_CEC_DSI], 0x36, v_total & 0xff);
+	ret |= regmap_write(lt->regmap[I2C_CEC_DSI], 0x37, v_total >> 8);
+
+	ret |= regmap_write(lt->regmap[I2C_CEC_DSI], 0x38, vbp & 0xff);
+	ret |= regmap_write(lt->regmap[I2C_CEC_DSI], 0x39, vbp >> 8);
+
+	ret |= regmap_write(lt->regmap[I2C_CEC_DSI], 0x3a, vfp & 0xff);
+	ret |= regmap_write(lt->regmap[I2C_CEC_DSI], 0x3b, vfp >> 8);
+
+	ret |= regmap_write(lt->regmap[I2C_CEC_DSI], 0x3c, hbp & 0xff);
+	ret |= regmap_write(lt->regmap[I2C_CEC_DSI], 0x3d, hbp >> 8);
+
+	ret |= regmap_write(lt->regmap[I2C_CEC_DSI], 0x3e, hfp & 0xff);
+	ret |= regmap_write(lt->regmap[I2C_CEC_DSI], 0x3f, hfp >> 8);
+
+	return ret;
+}
+
+static int lt8912_soft_power_on(struct lt8912 *lt)
+{
+	int ret = 0;
+	if (!lt->is_power_on) {
+		u32 lanes = lt->data_lanes;
+
+		unsigned int version[2] = {};
+		ret =  regmap_read(lt->regmap[I2C_MAIN], 0x00, &version[0]);
+		if(0 > ret) {
+			return ret;
+		}
+		ret = regmap_read(lt->regmap[I2C_MAIN], 0x01, &version[1]);
+		if(0 > ret) {
+			return ret;
+		}
+		dev_info(lt->dev, "LT8912 ID: %02x%02x\n", version[0], version[1]);
+
+		ret = lt8912_write_init_config(lt);
+		if(ret < 0) {
+			return ret;
+		}
+
+		ret = regmap_write(lt->regmap[I2C_CEC_DSI], 0x13, lanes & 3);
+		if(ret < 0) {
+			return ret;
+		}
+
+		ret = lt8912_write_mipi_basic_config(lt);
+		if(ret < 0) {
+			return ret;
+		}
+
+		lt->is_power_on = true;
+	}
+
+	return 0;
+}
+
+static int lt8912_video_on(struct lt8912 *lt)
+{
+	int ret;
+
+	ret = lt8912_video_setup(lt);
+	if (ret < 0) {
+		goto end;
+	}
+
+	ret = lt8912_write_dds_config(lt);
+	if (ret < 0) {
+		goto end;
+	}
+
+	ret = lt8912_write_rxlogicres_config(lt);
+	if (ret < 0) {
+		goto end;
+	}
+
+	ret = lt8912_write_lvds_config(lt);
+	if (ret < 0) {
+		goto end;
+	}
+
+end:
+	return ret;
+}
+
+static enum drm_connector_status lt8912_check_cable_status(struct lt8912 *lt)
+{
+	int ret;
+	unsigned int reg_val;
+
+	ret = regmap_read(lt->regmap[I2C_MAIN], 0xC1, &reg_val);
+	if (ret)
+		return connector_status_unknown;
+
+	if (reg_val & BIT(7))
+		return connector_status_connected;
+
+	return connector_status_disconnected;
+}
+
+static enum drm_connector_status
+lt8912_connector_detect(struct drm_connector *connector, bool force)
+{
+	struct lt8912 *lt = connector_to_lt8912(connector);
+
+	if (lt->hdmi_port->ops & DRM_BRIDGE_OP_DETECT) {
+		return drm_bridge_detect(lt->hdmi_port);
+	}
+	return lt8912_check_cable_status(lt);
+}
+
+static const struct drm_connector_funcs lt8912_connector_funcs = {
+	.detect = lt8912_connector_detect,
+	.fill_modes = drm_helper_probe_single_connector_modes,
+	.destroy = drm_connector_cleanup,
+	.reset = drm_atomic_helper_connector_reset,
+	.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,
+};
+
+static enum drm_mode_status
+lt8912_connector_mode_valid(struct drm_connector *connector,
+			    struct drm_display_mode *mode)
+{
+	if (mode->clock > 150000) {
+		return MODE_CLOCK_HIGH;
+	}
+
+	if (mode->hdisplay > 1920) {
+		return MODE_BAD_HVALUE;
+	}
+
+	if (mode->vdisplay > 1080) {
+		return MODE_BAD_VVALUE;
+	}
+
+	return MODE_OK;
+}
+
+static int lt8912_connector_get_modes(struct drm_connector *connector)
+{
+	struct edid *edid;
+	int ret = -1;
+	int num = 0;
+	struct lt8912 *lt = connector_to_lt8912(connector);
+	u32 bus_format = MEDIA_BUS_FMT_RGB888_1X24;
+
+	edid = drm_bridge_get_edid(lt->hdmi_port, connector);
+	if (!edid) {
+		if ((edid = kmalloc(sizeof(edid_data), GFP_KERNEL)) == NULL)
+			return NULL;
+		memcpy(edid, edid_data, sizeof(edid_data));
+	}
+
+	drm_connector_update_edid_property(connector, edid);
+	num = drm_add_edid_modes(connector, edid);
+
+	ret = drm_display_info_set_bus_formats(&connector->display_info,
+					       &bus_format, 1);
+	if (ret)
+		num = ret;
+
+	kfree(edid);
+	return num;
+}
+
+static const struct drm_connector_helper_funcs lt8912_connector_helper_funcs = {
+	.get_modes = lt8912_connector_get_modes,
+	.mode_valid = lt8912_connector_mode_valid,
+};
+
+static void lt8912_bridge_mode_set(struct drm_bridge *bridge,
+				   const struct drm_display_mode *mode,
+				   const struct drm_display_mode *adj)
+{
+	struct lt8912 *lt = bridge_to_lt8912(bridge);
+
+	dev_dbg(lt->dev, "%s: "
+					"clock %d, "
+					"hdisplay %d, "
+					"vdisplay %d, "
+
+					"crtc_clock %d, "
+					"crtc_hdisplay %d, "
+					"crtc_vdisplay %d, "
+
+					"width_mm %d, "
+					"height_mm %d, "
+					"name %s\n"
+
+					, __func__,
+					mode->clock,
+					mode->hdisplay,
+					mode->vdisplay,
+					mode->crtc_clock,
+					mode->crtc_hdisplay,
+					mode->crtc_vdisplay,
+					mode->width_mm,
+					mode->height_mm,
+					mode->name
+					);
+
+	drm_display_mode_to_videomode(adj, &lt->mode);
+}
+
+static void lt8912_bridge_enable(struct drm_bridge *bridge)
+{
+	struct lt8912 *lt = bridge_to_lt8912(bridge);
+
+	lt8912_video_on(lt);
+}
+
+static int lt8912_attach_dsi(struct lt8912 *lt)
+{
+	struct device *dev = lt->dev;
+	struct mipi_dsi_host *host;
+	struct mipi_dsi_device *dsi;
+	int ret = -1;
+	const struct mipi_dsi_device_info info = { .type = "lt8912",
+						   .channel = 0,
+						   .node = NULL,
+						 };
+
+	host = of_find_mipi_dsi_host_by_node(lt->host_node);
+	if (!host) {
+		return -EPROBE_DEFER;
+	}
+
+	dsi = mipi_dsi_device_register_full(host, &info);
+	if (IS_ERR(dsi)) {
+		ret = PTR_ERR(dsi);
+		dev_err(dev, "failed to create dsi device (%d)\n", ret);
+		goto err_dsi_device;
+	}
+
+	lt->dsi = dsi;
+
+	dsi->lanes = lt->data_lanes;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO
+					| MIPI_DSI_MODE_VIDEO_SYNC_PULSE
+					| MIPI_DSI_MODE_VIDEO_HSE;
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		goto err_dsi_attach;
+	}
+
+	return 0;
+
+err_dsi_attach:
+	mipi_dsi_device_unregister(dsi);
+err_dsi_device:
+	return ret;
+}
+
+static void lt8912_detach_dsi(struct lt8912 *lt)
+{
+	mipi_dsi_detach(lt->dsi);
+	mipi_dsi_device_unregister(lt->dsi);
+}
+
+static int lt8912_bridge_connector_init(struct drm_bridge *bridge)
+{
+	int ret;
+	struct lt8912 *lt = bridge_to_lt8912(bridge);
+	struct drm_connector *connector = &lt->connector;
+
+	connector->polled = DRM_CONNECTOR_POLL_CONNECT |
+			    DRM_CONNECTOR_POLL_DISCONNECT;
+
+	ret = drm_connector_init(bridge->dev, connector,
+				 &lt8912_connector_funcs,
+				 lt->hdmi_port->type);
+	if (ret)
+		goto exit;
+
+	drm_connector_helper_add(connector, &lt8912_connector_helper_funcs);
+
+	connector->dpms = DRM_MODE_DPMS_OFF;
+	drm_connector_attach_encoder(connector, bridge->encoder);
+
+exit:
+	return ret;
+}
+
+static int lt8912_bridge_attach(struct drm_bridge *bridge,
+				enum drm_bridge_attach_flags flags)
+{
+	struct lt8912 *lt = bridge_to_lt8912(bridge);
+	int ret;
+
+	if (!(flags & DRM_BRIDGE_ATTACH_NO_CONNECTOR)) {
+		ret = lt8912_bridge_connector_init(bridge);
+		if (ret) {
+			return ret;
+		}
+	}
+
+	ret = lt8912_hard_power_on(lt);
+	if (ret)
+		return ret;
+
+	ret = lt8912_soft_power_on(lt);
+	if (ret)
+		goto error;
+
+	ret = lt8912_attach_dsi(lt);
+	if (ret)
+		goto error;
+
+	lt->is_attached = true;
+
+	return 0;
+
+error:
+	lt8912_hard_power_off(lt);
+	return ret;
+}
+
+static void lt8912_bridge_detach(struct drm_bridge *bridge)
+{
+	struct lt8912 *lt = bridge_to_lt8912(bridge);
+
+	if (lt->is_attached) {
+		lt8912_detach_dsi(lt);
+		lt8912_hard_power_off(lt);
+		drm_connector_unregister(&lt->connector);
+		drm_connector_cleanup(&lt->connector);
+	}
+}
+
+static enum drm_connector_status
+lt8912_bridge_detect(struct drm_bridge *bridge)
+{
+	struct lt8912 *lt = bridge_to_lt8912(bridge);
+
+	if (lt->hdmi_port->ops & DRM_BRIDGE_OP_DETECT) {
+		return drm_bridge_detect(lt->hdmi_port);
+	}
+
+	return lt8912_check_cable_status(lt);
+}
+
+static struct edid *lt8912_bridge_get_edid(struct drm_bridge *bridge,
+					   struct drm_connector *connector)
+{
+	struct lt8912 *lt = bridge_to_lt8912(bridge);
+
+	/*
+	 * edid must be read through the ddc bus but it must be
+	 * given to the hdmi connector node.
+	 */
+	if (lt->hdmi_port->ops & DRM_BRIDGE_OP_EDID) {
+		return drm_bridge_get_edid(lt->hdmi_port, connector);
+	}
+
+	dev_warn(lt->dev, "The connected bridge does not supports DRM_BRIDGE_OP_EDID\n");
+	return NULL;
+}
+
+static const struct drm_bridge_funcs lt8912_bridge_funcs = {
+	.attach = lt8912_bridge_attach,
+	.detach = lt8912_bridge_detach,
+	.mode_set = lt8912_bridge_mode_set,
+	.enable = lt8912_bridge_enable,
+	.detect = lt8912_bridge_detect,
+	.get_edid = lt8912_bridge_get_edid,
+};
+
+static int lt8912_parse_dt(struct lt8912 *lt)
+{
+	struct gpio_desc *gp_reset;
+	struct device *dev = lt->dev;
+	int ret;
+	int data_lanes;
+	struct device_node *port_node;
+	struct device_node *endpoint;
+
+	gp_reset = devm_gpiod_get_optional(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(gp_reset)) {
+		ret = PTR_ERR(gp_reset);
+		if (ret != -EPROBE_DEFER) {
+			dev_err(dev, "Failed to get reset gpio: %d\n", ret);
+			return ret;
+		}
+	}
+	lt->gp_reset = gp_reset;
+
+	endpoint = of_graph_get_endpoint_by_regs(dev->of_node, 0, -1);
+	if (!endpoint)
+		return -ENODEV;
+
+
+	data_lanes = of_property_count_u32_elems(endpoint, "data-lanes");
+	of_node_put(endpoint);
+	if (data_lanes < 0) {
+		dev_err(dev, "Bad data-lanes property: %d\n", data_lanes);
+		return data_lanes;
+	}
+	lt->data_lanes = data_lanes;
+
+	lt->host_node = of_graph_get_remote_node(dev->of_node, 0, -1);
+	if (!lt->host_node) {
+		dev_err(dev, "Failed to get host port\n");
+		return -ENODEV;
+	}
+
+	port_node = of_graph_get_remote_node(dev->of_node, 1, -1);
+	if (!port_node) {
+		dev_err(dev, "Failed to get connector port\n");
+		ret = -ENODEV;
+		goto err_free_host_node;
+	}
+
+	lt->hdmi_port = of_drm_find_bridge(port_node);
+	if (!lt->hdmi_port) {
+		dev_dbg(dev, "Failed to get hdmi port\n");
+		ret = -EPROBE_DEFER;
+		goto err_free_host_node;
+	}
+
+	if (!of_device_is_compatible(port_node, "hdmi-connector")) {
+		dev_err(dev, "Uncompatible hdmi port\n");
+		ret = -EINVAL;
+		goto err_free_host_node;
+	}
+
+	of_node_put(port_node);
+	return 0;
+
+err_free_host_node:
+	of_node_put(port_node);
+	of_node_put(lt->host_node);
+	return ret;
+}
+
+static int lt8912_put_dt(struct lt8912 *lt)
+{
+	of_node_put(lt->host_node);
+	return 0;
+}
+
+static int lt8912_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	static struct lt8912 *lt;
+	int ret = 0;
+	struct device *dev = &client->dev;
+
+	lt = devm_kzalloc(dev, sizeof(struct lt8912), GFP_KERNEL);
+	if (!lt)
+		return -ENOMEM;
+
+	lt->dev = dev;
+	lt->i2c_client[0] = client;
+
+	ret = lt8912_parse_dt(lt);
+	if (ret)
+		goto err_dt_parse;
+
+	ret = lt8912_init_i2c(lt, client);
+	if (ret)
+		goto err_i2c;
+
+	i2c_set_clientdata(client, lt);
+
+	lt->bridge.funcs = &lt8912_bridge_funcs;
+	lt->bridge.of_node = dev->of_node;
+	lt->bridge.ops = (  DRM_BRIDGE_OP_EDID
+			  		  | DRM_BRIDGE_OP_DETECT
+					 );
+
+	drm_bridge_add(&lt->bridge);
+
+	return 0;
+
+err_i2c:
+	lt8912_put_dt(lt);
+err_dt_parse:
+	return ret;
+}
+
+static int lt8912_remove(struct i2c_client *client)
+{
+	struct lt8912 *lt = i2c_get_clientdata(client);
+
+	lt8912_bridge_detach(&lt->bridge);
+	drm_bridge_remove(&lt->bridge);
+	lt8912_free_i2c(lt);
+	lt8912_put_dt(lt);
+	return 0;
+}
+
+static const struct of_device_id lt8912_dt_match[] = {
+	{.compatible = "lontium,lt8912b"},
+	{}
+};
+MODULE_DEVICE_TABLE(of, lt8912_dt_match);
+
+static const struct i2c_device_id lt8912_id[] = {
+	{"lt8912", 0},
+	{},
+};
+MODULE_DEVICE_TABLE(i2c, lt8912_id);
+
+static struct i2c_driver lt8912_i2c_driver = {
+	.driver = {
+		.name = "lt8912",
+		.of_match_table = lt8912_dt_match,
+		.owner = THIS_MODULE,
+	},
+	.probe = lt8912_probe,
+	.remove = lt8912_remove,
+	.id_table = lt8912_id,
+};
+module_i2c_driver(lt8912_i2c_driver);
+
+MODULE_AUTHOR("Adrien Grassein <adrien.grassein@gmail.com>");
+MODULE_DESCRIPTION("lt8912 drm driver");
+MODULE_LICENSE("GPL v2");
\ No newline at end of file
diff --git a/drivers/gpu/drm/panel/Kconfig b/drivers/gpu/drm/panel/Kconfig
index 6153972e0127..785feb502969 100644
--- a/drivers/gpu/drm/panel/Kconfig
+++ b/drivers/gpu/drm/panel/Kconfig
@@ -97,7 +97,16 @@ config DRM_PANEL_FEIYANG_FY07024DI26A30D
 	  Say Y if you want to enable support for panels based on the
 	  Feiyang FY07024DI26A30-D MIPI-DSI interface.

-config DRM_PANEL_ILITEK_IL9322
+config DRM_PANEL_FITIPOWER_EK79007AD
+	tristate "Fitipower EK79007AD-based panels"
+	depends on OF
+	depends on DRM_MIPI_DSI
+	depends on BACKLIGHT_CLASS_DEVICE
+	help
+	  Say Y if you want to enable support for panels based on the
+	  Fitipower EK79007AD controller.
+
+ config DRM_PANEL_ILITEK_IL9322
 	tristate "Ilitek ILI9322 320x240 QVGA panels"
 	depends on OF && SPI
 	select REGMAP
@@ -500,4 +509,5 @@ config DRM_PANEL_XINPENG_XPP055C272
 	  Say Y here if you want to enable support for the Xinpeng
 	  XPP055C272 controller for 720x1280 LCD panels with MIPI/RGB/SPI
 	  system interfaces.
+
 endmenu
diff --git a/drivers/gpu/drm/panel/Makefile b/drivers/gpu/drm/panel/Makefile
index 2ba560bca61d..81a0d1f5b2e7 100644
--- a/drivers/gpu/drm/panel/Makefile
+++ b/drivers/gpu/drm/panel/Makefile
@@ -53,3 +53,4 @@ obj-$(CONFIG_DRM_PANEL_TPO_TPG110) += panel-tpo-tpg110.o
 obj-$(CONFIG_DRM_PANEL_TRULY_NT35597_WQXGA) += panel-truly-nt35597.o
 obj-$(CONFIG_DRM_PANEL_VISIONOX_RM69299) += panel-visionox-rm69299.o
 obj-$(CONFIG_DRM_PANEL_XINPENG_XPP055C272) += panel-xinpeng-xpp055c272.o
+obj-$(CONFIG_DRM_PANEL_FITIPOWER_EK79007AD) += panel-fitipower-ek79007ad.o
diff --git a/drivers/gpu/drm/panel/panel-fitipower-ek79007ad.c b/drivers/gpu/drm/panel/panel-fitipower-ek79007ad.c
new file mode 100644
index 000000000000..01283d26cda5
--- /dev/null
+++ b/drivers/gpu/drm/panel/panel-fitipower-ek79007ad.c
@@ -0,0 +1,334 @@
+// SPDX-License-Identifier: GPL-2.0
+
+// #define DEBUG
+
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/errno.h>
+#include <linux/fb.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+
+#include <linux/gpio/consumer.h>
+#include <linux/regulator/consumer.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+
+#include <video/mipi_display.h>
+
+struct ek79007ad_instr {
+	u8	cmd;
+	u8	data;
+};
+
+struct ek79007ad_desc {
+	const struct ek79007ad_instr* init;
+	const size_t init_length;
+	const struct drm_display_mode* mode;
+};
+
+struct ek79007ad {
+	struct drm_panel panel;
+	struct mipi_dsi_device* dsi;
+	const struct ek79007ad_desc* desc;
+
+	struct regulator* power;
+	struct gpio_desc* enable_gpio;
+	struct gpio_desc* reset;
+};
+
+#define EK79007AD_COMMAND_INSTR(_cmd, _data)		\
+	{						\
+		.cmd = (_cmd),		\
+		.data = (_data),	\
+	}
+
+/* support new panel vklcd07 (kwh070kq40-c08) */
+static const struct ek79007ad_instr ek79007ad_init_vklcd07[] = {
+	EK79007AD_COMMAND_INSTR(0xB0, 0x80),
+	EK79007AD_COMMAND_INSTR(0xB1, 0x00),
+	EK79007AD_COMMAND_INSTR(0xB2, 0x00),
+	EK79007AD_COMMAND_INSTR(0xB3, 0x00),
+};
+
+static inline struct ek79007ad* panel_to_ek79007ad(struct drm_panel* panel) {
+	return container_of(panel, struct ek79007ad, panel);
+}
+
+static int ek79007ad_send_cmd_data(struct ek79007ad* ctx, u8 cmd, u8 data) {
+	u8 buf[2] = { cmd, data };
+	int ret;
+
+	ret = mipi_dsi_dcs_write_buffer(ctx->dsi, buf, sizeof(buf));
+	if (ret < 0) {
+		dev_err(&ctx->dsi->dev, "Write fault %d\n", ret);
+		return ret;
+	}
+	return 0;
+}
+
+static int ek79007ad_read_cmd_data(struct ek79007ad* tftcp, u8 cmd) {
+	u8 buf = 0;
+	int ret;
+
+	ret = mipi_dsi_dcs_read(tftcp->dsi, cmd, &buf, sizeof(buf));
+	if (ret < 0) {
+		dev_err(&tftcp->dsi->dev, "mipi_dsi_dcs_read  fault(%d)\n", ret);
+	}
+
+	return buf;
+}
+#ifdef DEBUG
+static void ek79007ad_dump_reg(struct ek79007ad* ctx) {
+	unsigned int i;
+	const u8 reg_dump_addr[] = {
+		0x0A, 0x0D, 0x0E, 0x0F, 0x36, 0x80, 0x81, 0x82,
+		0x83, 0x84, 0x85, 0xB0, 0xB1, 0xB2, 0xB3
+	};
+
+	for (i = 0; i < ARRAY_SIZE(reg_dump_addr); i++) {
+		u8 addr = reg_dump_addr[i];
+		dev_dbg(&ctx->dsi->dev, "Read reg[%02X] = %02X\n", addr,
+			ek79007ad_read_cmd_data(ctx, addr));
+	}
+}
+#endif
+static int ek79007ad_prepare(struct drm_panel* panel) {
+	struct ek79007ad* ctx = panel_to_ek79007ad(panel);
+	unsigned int i;
+	u8 reg_b2;
+	int ret;
+
+	/* Power the panel */
+	ret = regulator_enable(ctx->power);
+	if (ret)
+		return ret;
+	msleep(40);
+
+	/* And reset it */
+	gpiod_set_value(ctx->reset, 1);
+	msleep(30);
+
+	gpiod_set_value(ctx->reset, 0);
+	msleep(60);
+
+#ifdef DEBUG
+	ek79007ad_dump_reg(ctx);
+#endif
+	for (i = 0; i < ctx->desc->init_length; i++) {
+		const struct ek79007ad_instr* instr = &ctx->desc->init[i];
+		ret = ek79007ad_send_cmd_data(ctx, instr->cmd, instr->data);
+		if (ret)
+			return ret;
+	}
+
+	reg_b2 = 0;
+	switch (ctx->dsi->lanes) {
+	case 2:
+		break;
+	case 3:
+		reg_b2 |= 0x10;
+		break;
+	case 4:
+		reg_b2 |= 0x30;
+		break;
+	default:
+		return -EINVAL;
+	}
+	ret = ek79007ad_send_cmd_data(ctx, 0xB2, reg_b2);
+	if (ret)
+		return ret;
+
+#ifdef DEBUG
+	ek79007ad_dump_reg(ctx);
+#endif
+	ret = mipi_dsi_dcs_set_tear_on(ctx->dsi, MIPI_DSI_DCS_TEAR_MODE_VBLANK);
+	if (ret)
+		return ret;
+
+	ret = mipi_dsi_dcs_exit_sleep_mode(ctx->dsi);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static int ek79007ad_enable(struct drm_panel* panel) {
+	struct ek79007ad* ctx = panel_to_ek79007ad(panel);
+
+	msleep(30);
+
+	return mipi_dsi_dcs_exit_sleep_mode(ctx->dsi);
+}
+
+static int ek79007ad_disable(struct drm_panel* panel) {
+	struct ek79007ad* ctx = panel_to_ek79007ad(panel);
+
+	return mipi_dsi_dcs_enter_sleep_mode(ctx->dsi);
+}
+
+static int ek79007ad_unprepare(struct drm_panel* panel) {
+	struct ek79007ad* ctx = panel_to_ek79007ad(panel);
+	int ret;
+
+	ret = ek79007ad_send_cmd_data(ctx, 0xB0, 0);
+	if (ret < 0) {
+		dev_err(&ctx->dsi->dev, "Write fault %d\n", ret);
+	}
+
+	mipi_dsi_dcs_enter_sleep_mode(ctx->dsi);
+	regulator_disable(ctx->power);
+	gpiod_set_value(ctx->reset, 1);
+
+	return 0;
+}
+
+static const struct drm_display_mode vklcd07_default_mode = {
+	.clock = 51200,
+
+	.hdisplay = 1024,
+	.hsync_start = 1024 + 160,
+	.hsync_end = 1024 + 160 + 1,
+	.htotal = 1024 + 160 + 1 + 160,
+
+	.vdisplay = 600,
+	.vsync_start = 600 + 23,
+	.vsync_end = 600 + 23 + 1,
+	.vtotal = 600 + 23 + 1 + 12,
+
+	.width_mm = 154,
+	.height_mm = 86,
+};
+
+static int ek79007ad_get_modes(struct drm_panel* panel,
+	struct drm_connector* connector) {
+	struct ek79007ad* ctx = panel_to_ek79007ad(panel);
+	struct drm_display_mode* mode;
+
+	mode = drm_mode_duplicate(connector->dev, ctx->desc->mode);
+	if (!mode) {
+		dev_err(&ctx->dsi->dev, "failed to add mode %ux%ux@%u\n",
+			ctx->desc->mode->hdisplay,
+			ctx->desc->mode->vdisplay,
+			drm_mode_vrefresh(ctx->desc->mode));
+		return -ENOMEM;
+	}
+
+	drm_mode_set_name(mode);
+
+	mode->type = DRM_MODE_TYPE_DRIVER | DRM_MODE_TYPE_PREFERRED;
+	drm_mode_probed_add(connector, mode);
+
+	connector->display_info.width_mm = mode->width_mm;
+	connector->display_info.height_mm = mode->height_mm;
+
+	return 1;
+}
+
+static const struct drm_panel_funcs ek79007ad_funcs = {
+	.prepare = ek79007ad_prepare,
+	.unprepare = ek79007ad_unprepare,
+	.enable = ek79007ad_enable,
+	.disable = ek79007ad_disable,
+	.get_modes = ek79007ad_get_modes,
+};
+
+static int ek79007ad_dsi_probe(struct mipi_dsi_device* dsi) {
+	struct ek79007ad* ctx;
+	int ret;
+
+	ctx = devm_kzalloc(&dsi->dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+	mipi_dsi_set_drvdata(dsi, ctx);
+	ctx->dsi = dsi;
+	ctx->desc = of_device_get_match_data(&dsi->dev);
+
+	if (ek79007ad_init_vklcd07 == ctx->desc->init) {
+		dev_notice(&dsi->dev, "Initialize Vekatech VKLCD07 display\n");
+	}
+	drm_panel_init(&ctx->panel, &dsi->dev, &ek79007ad_funcs,
+		DRM_MODE_CONNECTOR_DSI);
+
+	ctx->power = devm_regulator_get(&dsi->dev, "power");
+	if (IS_ERR(ctx->power)) {
+		dev_err(&dsi->dev, "Couldn't get our power regulator\n");
+		return PTR_ERR(ctx->power);
+	}
+
+	/* The enable GPIO is optional, this pin is MIPI DSI/HDMI switch select input. */
+	ctx->enable_gpio = devm_gpiod_get_optional(&dsi->dev, "switch", GPIOD_OUT_HIGH);
+	if (IS_ERR_OR_NULL(ctx->enable_gpio)) {
+		dev_dbg(&dsi->dev, "Couldn't get our switch GPIO\n");
+		ctx->enable_gpio = NULL;
+	}
+	gpiod_set_value(ctx->enable_gpio, 1);
+
+	ctx->reset = devm_gpiod_get(&dsi->dev, "reset", GPIOD_OUT_LOW);
+	if (IS_ERR(ctx->reset)) {
+		dev_err(&dsi->dev, "Couldn't get our reset GPIO\n");
+		return PTR_ERR(ctx->reset);
+	}
+	ret = of_property_read_u32(dsi->dev.of_node, "dsi-lanes", &dsi->lanes);
+	if (ret < 0) {
+		dev_dbg(&dsi->dev, "Failed to get dsi-lanes property, use default setting - 4 lanes\n");
+		dsi->lanes = 4;
+	} else {
+		dev_dbg(&dsi->dev, "dsi-lanes = %d\n", dsi->lanes);
+	}
+
+	ret = drm_panel_of_backlight(&ctx->panel);
+	if (ret) {
+		dev_err(&dsi->dev, "Couldn't get our backlight(%d)\n", ret);
+		return ret;
+	}
+
+	drm_panel_add(&ctx->panel);
+
+	/* non-burst mode with sync pulse */
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO_SYNC_PULSE | MIPI_DSI_MODE_LPM;
+
+	dsi->format = MIPI_DSI_FMT_RGB888;
+
+	ret = mipi_dsi_attach(dsi);
+	return ret;
+}
+
+static int ek79007ad_dsi_remove(struct mipi_dsi_device* dsi) {
+	struct ek79007ad* ctx = mipi_dsi_get_drvdata(dsi);
+
+	mipi_dsi_detach(dsi);
+	drm_panel_remove(&ctx->panel);
+
+	return 0;
+}
+
+static const struct ek79007ad_desc vklcd07_desc = {
+	.init = ek79007ad_init_vklcd07,
+	.init_length = ARRAY_SIZE(ek79007ad_init_vklcd07),
+	.mode = &vklcd07_default_mode,
+};
+
+static const struct of_device_id ek79007ad_of_match[] = {
+	{.compatible = "vekatech,vklcd07", .data = &vklcd07_desc },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, ek79007ad_of_match);
+
+static struct mipi_dsi_driver ek79007ad_dsi_driver = {
+	.probe = ek79007ad_dsi_probe,
+	.remove = ek79007ad_dsi_remove,
+	.driver = {
+		.name = "ek79007ad-dsi",
+		.of_match_table = ek79007ad_of_match,
+	},
+};
+module_mipi_dsi_driver(ek79007ad_dsi_driver);
+
+MODULE_AUTHOR("Stanimir Bonev <bonev.stanimir@gmail.com>");
+MODULE_DESCRIPTION("Fitipower ek79007ad Controller Driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/panel/panel-ilitek-ili9881c.c b/drivers/gpu/drm/panel/panel-ilitek-ili9881c.c
index 534dd7414d42..a29896a17547 100644
--- a/drivers/gpu/drm/panel/panel-ilitek-ili9881c.c
+++ b/drivers/gpu/drm/panel/panel-ilitek-ili9881c.c
@@ -3,6 +3,8 @@
  * Copyright (C) 2017-2018, Bootlin
  */

+//#define DEBUG
+
 #include <linux/delay.h>
 #include <linux/device.h>
 #include <linux/err.h>
@@ -21,6 +23,8 @@

 #include <video/mipi_display.h>

+// #define CONFIG_SELFTEST_MODE
+
 enum ili9881c_op {
 	ILI9881C_SWITCH_PAGE,
 	ILI9881C_COMMAND,
@@ -50,6 +54,7 @@ struct ili9881c {
 	const struct ili9881c_desc	*desc;

 	struct regulator	*power;
+	struct gpio_desc	*enable_gpio;
 	struct gpio_desc	*reset;
 };

@@ -453,6 +458,215 @@ static const struct ili9881c_instr k101_im2byl02_init[] = {
 	ILI9881C_COMMAND_INSTR(0xD3, 0x3F), /* VN0 */
 };

+/* support new panel PH720128T005ZBC */
+static const struct ili9881c_instr ili9881c_init_ph720128t005[] = {
+	ILI9881C_SWITCH_PAGE_INSTR(3),
+	ILI9881C_COMMAND_INSTR(0x01, 0x00),
+	ILI9881C_COMMAND_INSTR(0x02, 0x00),
+	ILI9881C_COMMAND_INSTR(0x03, 0x73),
+	ILI9881C_COMMAND_INSTR(0x04, 0x00),
+	ILI9881C_COMMAND_INSTR(0x05, 0x00),
+	ILI9881C_COMMAND_INSTR(0x06, 0x0A),
+	ILI9881C_COMMAND_INSTR(0x07, 0x00),
+	ILI9881C_COMMAND_INSTR(0x08, 0x00),
+	ILI9881C_COMMAND_INSTR(0x09, 0x61),
+	ILI9881C_COMMAND_INSTR(0x0A, 0x00),
+	ILI9881C_COMMAND_INSTR(0x0B, 0x00),
+	ILI9881C_COMMAND_INSTR(0x0C, 0x01),
+	ILI9881C_COMMAND_INSTR(0x0D, 0x00),
+	ILI9881C_COMMAND_INSTR(0x0E, 0x00),
+	ILI9881C_COMMAND_INSTR(0x0F, 0x61),
+	ILI9881C_COMMAND_INSTR(0x10, 0x61),
+	ILI9881C_COMMAND_INSTR(0x11, 0x00),
+	ILI9881C_COMMAND_INSTR(0x12, 0x00),
+	ILI9881C_COMMAND_INSTR(0x13, 0x00),
+	ILI9881C_COMMAND_INSTR(0x14, 0x00),
+	ILI9881C_COMMAND_INSTR(0x15, 0x00),
+	ILI9881C_COMMAND_INSTR(0x16, 0x00),
+	ILI9881C_COMMAND_INSTR(0x17, 0x00),
+	ILI9881C_COMMAND_INSTR(0x18, 0x00),
+	ILI9881C_COMMAND_INSTR(0x19, 0x00),
+	ILI9881C_COMMAND_INSTR(0x1A, 0x00),
+	ILI9881C_COMMAND_INSTR(0x1B, 0x00),
+	ILI9881C_COMMAND_INSTR(0x1C, 0x00),
+	ILI9881C_COMMAND_INSTR(0x1D, 0x00),
+	ILI9881C_COMMAND_INSTR(0x1E, 0x40),
+	ILI9881C_COMMAND_INSTR(0x1F, 0x80),
+	ILI9881C_COMMAND_INSTR(0x20, 0x06),
+	ILI9881C_COMMAND_INSTR(0x21, 0x01),
+	ILI9881C_COMMAND_INSTR(0x22, 0x00),
+	ILI9881C_COMMAND_INSTR(0x23, 0x00),
+	ILI9881C_COMMAND_INSTR(0x24, 0x00),
+	ILI9881C_COMMAND_INSTR(0x25, 0x00),
+	ILI9881C_COMMAND_INSTR(0x26, 0x00),
+	ILI9881C_COMMAND_INSTR(0x27, 0x00),
+	ILI9881C_COMMAND_INSTR(0x28, 0x33),
+	ILI9881C_COMMAND_INSTR(0x29, 0x03),
+	ILI9881C_COMMAND_INSTR(0x2A, 0x00),
+	ILI9881C_COMMAND_INSTR(0x2B, 0x00),
+	ILI9881C_COMMAND_INSTR(0x2C, 0x00),
+	ILI9881C_COMMAND_INSTR(0x2D, 0x00),
+	ILI9881C_COMMAND_INSTR(0x2E, 0x00),
+	ILI9881C_COMMAND_INSTR(0x2F, 0x00),
+	ILI9881C_COMMAND_INSTR(0x30, 0x00),
+	ILI9881C_COMMAND_INSTR(0x31, 0x00),
+	ILI9881C_COMMAND_INSTR(0x32, 0x00),
+	ILI9881C_COMMAND_INSTR(0x33, 0x00),
+	ILI9881C_COMMAND_INSTR(0x34, 0x04),
+	ILI9881C_COMMAND_INSTR(0x35, 0x00),
+	ILI9881C_COMMAND_INSTR(0x36, 0x00),
+	ILI9881C_COMMAND_INSTR(0x37, 0x00),
+	ILI9881C_COMMAND_INSTR(0x38, 0x3C),
+	ILI9881C_COMMAND_INSTR(0x39, 0x00),
+	ILI9881C_COMMAND_INSTR(0x3A, 0x00),
+	ILI9881C_COMMAND_INSTR(0x3B, 0x00),
+	ILI9881C_COMMAND_INSTR(0x3C, 0x00),
+	ILI9881C_COMMAND_INSTR(0x3D, 0x00),
+	ILI9881C_COMMAND_INSTR(0x3E, 0x00),
+	ILI9881C_COMMAND_INSTR(0x3F, 0x00),
+	ILI9881C_COMMAND_INSTR(0x40, 0x00),
+	ILI9881C_COMMAND_INSTR(0x41, 0x00),
+	ILI9881C_COMMAND_INSTR(0x42, 0x00),
+	ILI9881C_COMMAND_INSTR(0x43, 0x00),
+	ILI9881C_COMMAND_INSTR(0x44, 0x00),
+	ILI9881C_COMMAND_INSTR(0x50, 0x10),
+	ILI9881C_COMMAND_INSTR(0x51, 0x32),
+	ILI9881C_COMMAND_INSTR(0x52, 0x54),
+	ILI9881C_COMMAND_INSTR(0x53, 0x76),
+	ILI9881C_COMMAND_INSTR(0x54, 0x98),
+	ILI9881C_COMMAND_INSTR(0x55, 0xBA),
+	ILI9881C_COMMAND_INSTR(0x56, 0x10),
+	ILI9881C_COMMAND_INSTR(0x57, 0x32),
+	ILI9881C_COMMAND_INSTR(0x58, 0x54),
+	ILI9881C_COMMAND_INSTR(0x59, 0x76),
+	ILI9881C_COMMAND_INSTR(0x5A, 0x98),
+	ILI9881C_COMMAND_INSTR(0x5B, 0xBA),
+	ILI9881C_COMMAND_INSTR(0x5C, 0xDC),
+	ILI9881C_COMMAND_INSTR(0x5D, 0xFE),
+	ILI9881C_COMMAND_INSTR(0x5E, 0x00),
+	ILI9881C_COMMAND_INSTR(0x5F, 0x0E),
+	ILI9881C_COMMAND_INSTR(0x60, 0x0F),
+	ILI9881C_COMMAND_INSTR(0x61, 0x0C),
+	ILI9881C_COMMAND_INSTR(0x62, 0x0D),
+	ILI9881C_COMMAND_INSTR(0x63, 0x06),
+	ILI9881C_COMMAND_INSTR(0x64, 0x07),
+	ILI9881C_COMMAND_INSTR(0x65, 0x02),
+	ILI9881C_COMMAND_INSTR(0x66, 0x02),
+	ILI9881C_COMMAND_INSTR(0x67, 0x02),
+	ILI9881C_COMMAND_INSTR(0x68, 0x02),
+	ILI9881C_COMMAND_INSTR(0x69, 0x01),
+	ILI9881C_COMMAND_INSTR(0x6A, 0x00),
+	ILI9881C_COMMAND_INSTR(0x6B, 0x02),
+	ILI9881C_COMMAND_INSTR(0x6C, 0x15),
+	ILI9881C_COMMAND_INSTR(0x6D, 0x14),
+	ILI9881C_COMMAND_INSTR(0x6E, 0x02),
+	ILI9881C_COMMAND_INSTR(0x6F, 0x02),
+	ILI9881C_COMMAND_INSTR(0x70, 0x02),
+	ILI9881C_COMMAND_INSTR(0x71, 0x02),
+	ILI9881C_COMMAND_INSTR(0x72, 0x02),
+	ILI9881C_COMMAND_INSTR(0x73, 0x02),
+	ILI9881C_COMMAND_INSTR(0x74, 0x02),
+	ILI9881C_COMMAND_INSTR(0x75, 0x0E),
+	ILI9881C_COMMAND_INSTR(0x76, 0x0F),
+	ILI9881C_COMMAND_INSTR(0x77, 0x0C),
+	ILI9881C_COMMAND_INSTR(0x78, 0x0D),
+	ILI9881C_COMMAND_INSTR(0x79, 0x06),
+	ILI9881C_COMMAND_INSTR(0x7A, 0x07),
+	ILI9881C_COMMAND_INSTR(0x7B, 0x02),
+	ILI9881C_COMMAND_INSTR(0x7C, 0x02),
+	ILI9881C_COMMAND_INSTR(0x7D, 0x02),
+	ILI9881C_COMMAND_INSTR(0x7E, 0x02),
+	ILI9881C_COMMAND_INSTR(0x7F, 0x01),
+	ILI9881C_COMMAND_INSTR(0x80, 0x00),
+	ILI9881C_COMMAND_INSTR(0x81, 0x02),
+	ILI9881C_COMMAND_INSTR(0x82, 0x14),
+	ILI9881C_COMMAND_INSTR(0x83, 0x15),
+	ILI9881C_COMMAND_INSTR(0x84, 0x02),
+	ILI9881C_COMMAND_INSTR(0x85, 0x02),
+	ILI9881C_COMMAND_INSTR(0x86, 0x02),
+	ILI9881C_COMMAND_INSTR(0x87, 0x02),
+	ILI9881C_COMMAND_INSTR(0x88, 0x02),
+	ILI9881C_COMMAND_INSTR(0x89, 0x02),
+	ILI9881C_COMMAND_INSTR(0x8A, 0x02),
+	ILI9881C_COMMAND_INSTR(0x043, 0x00),
+	ILI9881C_SWITCH_PAGE_INSTR(4),
+	ILI9881C_COMMAND_INSTR(0x6C, 0x15),
+	ILI9881C_COMMAND_INSTR(0x6E, 0x2A),
+	ILI9881C_COMMAND_INSTR(0x6F, 0x33),
+	ILI9881C_COMMAND_INSTR(0x3B, 0x98),
+	ILI9881C_COMMAND_INSTR(0x3A, 0x94),
+	ILI9881C_COMMAND_INSTR(0x8D, 0x14),
+	ILI9881C_COMMAND_INSTR(0x87, 0xBA),
+	ILI9881C_COMMAND_INSTR(0x26, 0x76),
+	ILI9881C_COMMAND_INSTR(0xB2, 0xD1),
+	ILI9881C_COMMAND_INSTR(0xB5, 0x06),
+	ILI9881C_COMMAND_INSTR(0x38, 0x01),
+	ILI9881C_COMMAND_INSTR(0x39, 0x00),
+	ILI9881C_COMMAND_INSTR(0x088, 0x0B),
+	ILI9881C_SWITCH_PAGE_INSTR(1),
+	#ifdef AVT_DISPALY_ROTATE_180
+	ILI9881C_COMMAND_INSTR(0x22, 0x09),
+	#else
+	ILI9881C_COMMAND_INSTR(0x22, 0x0A),
+	#endif
+	ILI9881C_COMMAND_INSTR(0x31, 0x00),
+	ILI9881C_COMMAND_INSTR(0x53, 0x7D),
+	ILI9881C_COMMAND_INSTR(0x55, 0x8F),
+	ILI9881C_COMMAND_INSTR(0x40, 0x33),
+	ILI9881C_COMMAND_INSTR(0x50, 0x96),
+	ILI9881C_COMMAND_INSTR(0x51, 0x96),
+	ILI9881C_COMMAND_INSTR(0x60, 0x23),
+	ILI9881C_COMMAND_INSTR(0xA0, 0x08),
+	ILI9881C_COMMAND_INSTR(0xA1, 0x1D),
+	ILI9881C_COMMAND_INSTR(0xA2, 0x2A),
+	ILI9881C_COMMAND_INSTR(0xA3, 0x10),
+	ILI9881C_COMMAND_INSTR(0xA4, 0x15),
+	ILI9881C_COMMAND_INSTR(0xA5, 0x28),
+	ILI9881C_COMMAND_INSTR(0xA6, 0x1C),
+	ILI9881C_COMMAND_INSTR(0xA7, 0x1D),
+	ILI9881C_COMMAND_INSTR(0xA8, 0x7E),
+	ILI9881C_COMMAND_INSTR(0xA9, 0x1D),
+	ILI9881C_COMMAND_INSTR(0xAA, 0x29),
+	ILI9881C_COMMAND_INSTR(0xAB, 0x6B),
+	ILI9881C_COMMAND_INSTR(0xAC, 0x1A),
+	ILI9881C_COMMAND_INSTR(0xAD, 0x18),
+	ILI9881C_COMMAND_INSTR(0xAE, 0x4B),
+	ILI9881C_COMMAND_INSTR(0xAF, 0x20),
+	ILI9881C_COMMAND_INSTR(0xB0, 0x27),
+	ILI9881C_COMMAND_INSTR(0xB1, 0x50),
+	ILI9881C_COMMAND_INSTR(0xB2, 0x64),
+	ILI9881C_COMMAND_INSTR(0xB3, 0x39),
+	ILI9881C_COMMAND_INSTR(0xC0, 0x08),
+	ILI9881C_COMMAND_INSTR(0xC1, 0x1D),
+	ILI9881C_COMMAND_INSTR(0xC2, 0x2A),
+	ILI9881C_COMMAND_INSTR(0xC3, 0x10),
+	ILI9881C_COMMAND_INSTR(0xC4, 0x15),
+	ILI9881C_COMMAND_INSTR(0xC5, 0x28),
+	ILI9881C_COMMAND_INSTR(0xC6, 0x1C),
+	ILI9881C_COMMAND_INSTR(0xC7, 0x1D),
+	ILI9881C_COMMAND_INSTR(0xC8, 0x7E),
+	ILI9881C_COMMAND_INSTR(0xC9, 0x1D),
+	ILI9881C_COMMAND_INSTR(0xCA, 0x29),
+	ILI9881C_COMMAND_INSTR(0xCB, 0x6B),
+	ILI9881C_COMMAND_INSTR(0xCC, 0x1A),
+	ILI9881C_COMMAND_INSTR(0xCD, 0x18),
+	ILI9881C_COMMAND_INSTR(0xCE, 0x4B),
+	ILI9881C_COMMAND_INSTR(0xCF, 0x20),
+	ILI9881C_COMMAND_INSTR(0xD0, 0x27),
+	ILI9881C_COMMAND_INSTR(0xD1, 0x50),
+	ILI9881C_COMMAND_INSTR(0xD2, 0x64),
+	ILI9881C_COMMAND_INSTR(0xD3, 0x39),
+	ILI9881C_SWITCH_PAGE_INSTR(0),
+	ILI9881C_COMMAND_INSTR(0x35, 0x00),
+	ILI9881C_COMMAND_INSTR(0x11, 0x00),
+#ifdef CONFIG_SELFTEST_MODE
+/* BIST mode (Built-in Self-test Pattern)*/
+	ILI9881C_SWITCH_PAGE_INSTR(4),
+	ILI9881C_COMMAND_INSTR(0x2d, 0x80),
+	ILI9881C_COMMAND_INSTR(0x2f, 0x11),
+#endif
+};
+
 static inline struct ili9881c *panel_to_ili9881c(struct drm_panel *panel)
 {
 	return container_of(panel, struct ili9881c, panel);
@@ -493,6 +707,32 @@ static int ili9881c_send_cmd_data(struct ili9881c *ctx, u8 cmd, u8 data)
 	return 0;
 }

+static int ili9881c_read_cmd_data(struct ili9881c *tftcp, u8 cmd)
+{
+	u8 buf = 0;
+	int ret;
+
+	ret = mipi_dsi_dcs_read(tftcp->dsi, cmd, &buf, sizeof(buf));
+	if (ret < 0) {
+		dev_err(&tftcp->dsi->dev, "mipi_dsi_dcs_read  fault(%d)\n", ret);
+	}
+
+	return buf;
+}
+
+static void ili9881c_getID(struct ili9881c *tftcp)
+{
+	u8 id[3];
+
+	tftcp->dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+	ili9881c_switch_page(tftcp, 1);
+	id[0] = ili9881c_read_cmd_data(tftcp, 0x00);
+	id[1] = ili9881c_read_cmd_data(tftcp, 0x01);
+	id[2] = ili9881c_read_cmd_data(tftcp, 0x02);
+
+	dev_info(&tftcp->dsi->dev, "ID: 0x%02X 0x%02X 0x%02X \n", id[0], id[1], id[2]);
+}
+
 static int ili9881c_prepare(struct drm_panel *panel)
 {
 	struct ili9881c *ctx = panel_to_ili9881c(panel);
@@ -512,6 +752,8 @@ static int ili9881c_prepare(struct drm_panel *panel)
 	gpiod_set_value(ctx->reset, 0);
 	msleep(20);

+	ili9881c_getID(ctx);
+
 	for (i = 0; i < ctx->desc->init_length; i++) {
 		const struct ili9881c_instr *instr = &ctx->desc->init[i];

@@ -603,6 +845,23 @@ static const struct drm_display_mode k101_im2byl02_default_mode = {
 	.height_mm	= 217,
 };

+static const struct drm_display_mode ph720128t005_default_mode = {
+	.clock		= 48000,
+
+	.hdisplay	= 720,
+	.hsync_start	= 720 + 10,
+	.hsync_end	= 720 + 10 + 8,
+	.htotal		= 720 + 10 + 8 + 20,
+
+	.vdisplay	= 1280,
+	.vsync_start	= 1280 + 8,
+	.vsync_end	= 1280 + 8 + 2,
+	.vtotal		= 1280 + 8 + 2 + 14,
+
+	.width_mm	= 87,
+	.height_mm	= 155,
+};
+
 static int ili9881c_get_modes(struct drm_panel *panel,
 			      struct drm_connector *connector)
 {
@@ -649,6 +908,9 @@ static int ili9881c_dsi_probe(struct mipi_dsi_device *dsi)
 	ctx->dsi = dsi;
 	ctx->desc = of_device_get_match_data(&dsi->dev);

+	if(ili9881c_init_ph720128t005 == ctx->desc->init) {
+		dev_notice(&dsi->dev, "Found Avnet 720128t005 display\n");
+	}
 	drm_panel_init(&ctx->panel, &dsi->dev, &ili9881c_funcs,
 		       DRM_MODE_CONNECTOR_DSI);

@@ -658,21 +920,39 @@ static int ili9881c_dsi_probe(struct mipi_dsi_device *dsi)
 		return PTR_ERR(ctx->power);
 	}

+    /* The enable GPIO is optional, this pin is MIPI DSI/HDMI switch select input. */
+    ctx->enable_gpio = devm_gpiod_get_optional(&dsi->dev, "switch", GPIOD_OUT_HIGH);
+    if (IS_ERR_OR_NULL(ctx->enable_gpio)) {
+		dev_dbg(&dsi->dev, "Couldn't get our switch GPIO\n");
+		ctx->enable_gpio = NULL;
+    }
+	gpiod_set_value(ctx->enable_gpio, 1);
+
 	ctx->reset = devm_gpiod_get(&dsi->dev, "reset", GPIOD_OUT_LOW);
 	if (IS_ERR(ctx->reset)) {
 		dev_err(&dsi->dev, "Couldn't get our reset GPIO\n");
 		return PTR_ERR(ctx->reset);
 	}
+	ret = of_property_read_u32(dsi->dev.of_node, "dsi-lanes", &dsi->lanes);
+	if (ret < 0) {
+		dev_dbg(&dsi->dev, "Failed to get dsi-lanes property, use default setting\n");
+		dsi->lanes = 2;
+	} else {
+		dev_dbg(&dsi->dev, "dsi-lanes = %d\n", dsi->lanes);
+	}

 	ret = drm_panel_of_backlight(&ctx->panel);
-	if (ret)
+	if (ret) {
+		dev_err(&dsi->dev, "Couldn't get our backlight(%d)\n", ret);
 		return ret;
+	}

 	drm_panel_add(&ctx->panel);

+	/* non-burst mode with sync pulse */
 	dsi->mode_flags = MIPI_DSI_MODE_VIDEO_SYNC_PULSE;
+
 	dsi->format = MIPI_DSI_FMT_RGB888;
-	dsi->lanes = 4;

 	return mipi_dsi_attach(dsi);
 }
@@ -699,9 +979,16 @@ static const struct ili9881c_desc k101_im2byl02_desc = {
 	.mode = &k101_im2byl02_default_mode,
 };

+static const struct ili9881c_desc ph720128t005_desc = {
+	.init = ili9881c_init_ph720128t005,
+	.init_length = ARRAY_SIZE(ili9881c_init_ph720128t005),
+	.mode = &ph720128t005_default_mode,
+};
+
 static const struct of_device_id ili9881c_of_match[] = {
 	{ .compatible = "bananapi,lhr050h41", .data = &lhr050h41_desc },
 	{ .compatible = "feixin,k101-im2byl02", .data = &k101_im2byl02_desc },
+	{ .compatible = "avnet,ph720128t005", .data = &ph720128t005_desc },
 	{ }
 };
 MODULE_DEVICE_TABLE(of, ili9881c_of_match);
diff --git a/drivers/gpu/drm/rcar-du/rzg2l_mipi_dsi.c b/drivers/gpu/drm/rcar-du/rzg2l_mipi_dsi.c
index 65c1f11080f6..a44897e43e16 100644
--- a/drivers/gpu/drm/rcar-du/rzg2l_mipi_dsi.c
+++ b/drivers/gpu/drm/rcar-du/rzg2l_mipi_dsi.c
@@ -72,6 +72,7 @@ struct rzg2l_mipi_dsi {
 	unsigned long hsfreq;

 	bool hsclkmode;	/* 0 for non-continuous and 1 for continuous clock mode */
+	bool lt8912_dev;


 #define bridge_to_rzg2l_mipi_dsi(b) \
@@ -186,6 +187,12 @@ static int rzg2l_mipi_dsi_startup(struct rzg2l_mipi_dsi *mipi_dsi)
 		timings.ths_zero = 23;
 	}

+	/* LT8912 has different timings */
+	if(mipi_dsi->lt8912_dev) {
+		timings.tlpx = 1;
+		timings.ths_prepare = 1;
+	}
+
 	dphytim0 = DSIDPHYTIM0_TCLK_MISS(timings.tclk_miss) |
 		   DSIDPHYTIM0_T_INIT(timings.t_init);
 	dphytim1 = DSIDPHYTIM1_THS_PREPARE(timings.ths_prepare) |
@@ -274,6 +281,10 @@ static int rzg2l_mipi_dsi_startup(struct rzg2l_mipi_dsi *mipi_dsi)
 	lptrnstsetr = LPTRNSTSETR_GOLPBKT(golpbkt);
 	rzg2l_mipi_dsi_write(mipi_dsi->link_mmio, LPTRNSTSETR, lptrnstsetr);

+	dev_dbg(mipi_dsi->dev, "Set DPHY and LINK with %lu kHz, lanes %d\n",
+		mipi_dsi->hsfreq,
+		mipi_dsi->lanes
+	);
 	return 0;
 }

@@ -357,6 +368,11 @@ static void rzg2l_mipi_dsi_set_display_timing(struct rzg2l_mipi_dsi *mipi_dsi)

 	rzg2l_mipi_dsi_write(mipi_dsi->link_mmio, VICH1SET1R,
 			     VICH1SET1R_DLY(delay[mipi_dsi->hsclkmode]));
+
+	dev_dbg(mipi_dsi->dev, "Set MIPI format %x, mode_flag %x\n",
+		mipi_dsi->format,
+		mipi_dsi->mode_flags
+	);
 }

 static int rzg2l_mipi_dsi_start_hs_clock(struct rzg2l_mipi_dsi *mipi_dsi)
@@ -794,6 +810,14 @@ static int rzg2l_mipi_dsi_host_attach(struct mipi_dsi_host *host,
 	mipi_dsi->format = device->format;
 	mipi_dsi->mode_flags = device->mode_flags;

+	mipi_dsi->lt8912_dev = !strcmp(device->name, "lt8912");
+
+	dev_dbg(mipi_dsi->dev, "To host attach device %s lanes %d, format %x, mode_flag %x\n",
+		device->name,
+		mipi_dsi->lanes,
+		mipi_dsi->format,
+		mipi_dsi->mode_flags
+	);
 	return 0;
 }

diff --git a/drivers/mtd/spi-nor/macronix.c b/drivers/mtd/spi-nor/macronix.c
index 662b212787d4..6d74bb3cad62 100644
--- a/drivers/mtd/spi-nor/macronix.c
+++ b/drivers/mtd/spi-nor/macronix.c
@@ -64,7 +64,7 @@ static const struct flash_info macronix_parts[] = {
 	{ "mx25l25635e", INFO(0xc22019, 0, 64 * 1024, 512,
 			      SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ)
 		.fixups = &mx25l25635_fixups },
-	{ "mx25u25635f", INFO(0xc22539, 0, 64 * 1024, 512,
+	{ "mx25u25645g", INFO(0xc22539, 0, 64 * 1024, 512,
 			      SECT_4K | SPI_NOR_4B_OPCODES) },
 	{ "mx25u51245g", INFO(0xc2253a, 0, 64 * 1024, 1024,
 			      SECT_4K | SPI_NOR_DUAL_READ |
@@ -73,7 +73,7 @@ static const struct flash_info macronix_parts[] = {
 			      SECT_4K | SPI_NOR_DUAL_READ |
 			      SPI_NOR_QUAD_READ) },
 	{ "mx25l25655e", INFO(0xc22619, 0, 64 * 1024, 512, 0) },
-	{ "mx66l51235l", INFO(0xc2201a, 0, 64 * 1024, 1024,
+	{ "mx25l51245g", INFO(0xc2201a, 0, 64 * 1024, 1024,
 			      SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ |
 			      SPI_NOR_4B_OPCODES) },
 	{ "mx66u51235f", INFO(0xc2253a, 0, 64 * 1024, 1024,
diff --git a/drivers/net/phy/realtek.c b/drivers/net/phy/realtek.c
index b4879306bb8a..ff1e933b411e 100644
--- a/drivers/net/phy/realtek.c
+++ b/drivers/net/phy/realtek.c
@@ -29,6 +29,9 @@
 #define RTL8211F_PHYCR1				0x18
 #define RTL8211F_INSR				0x1d

+#define RTL8211F_LED_CRTL			0x10
+#define RTL8211F_EEE				0x11
+
 #define RTL8211F_TX_DELAY			BIT(8)
 #define RTL8211F_RX_DELAY			BIT(3)

@@ -185,6 +188,9 @@ static int rtl8211f_config_init(struct phy_device *phydev)
 	u16 val;
 	int ret;

+	phy_write_paged(phydev, 0xd04, RTL8211F_LED_CRTL, 0x617f);
+	phy_write_paged(phydev, 0xd04, RTL8211F_EEE, 0);
+
 	val = RTL8211F_ALDPS_ENABLE | RTL8211F_ALDPS_PLL_OFF | RTL8211F_ALDPS_XTAL_OFF;
 	phy_modify_paged_changed(phydev, 0xa43, RTL8211F_PHYCR1, val, val);

diff --git a/scripts/Makefile.lib b/scripts/Makefile.lib
index 94133708889d..82c1faf7f78f 100644
--- a/scripts/Makefile.lib
+++ b/scripts/Makefile.lib
@@ -325,6 +325,16 @@ cmd_dtc = $(HOSTCC) -E $(dtc_cpp_flags) -x assembler-with-cpp -o $(dtc-tmp) $< ;
 $(obj)/%.dtb: $(src)/%.dts $(DTC) FORCE
 	$(call if_changed_dep,dtc)

+quiet_cmd_dtco = DTCO     $@
+cmd_dtco = $(HOSTCC) -E $(dtc_cpp_flags) -x assembler-with-cpp -o $(dtc-tmp) $< ; \
+	$(DTC) -O dtb -o $@ -b 0 \
+		$(addprefix -i,$(dir $<) $(DTC_INCLUDE)) $(DTC_FLAGS) \
+		-d $(depfile).dtc.tmp $(dtc-tmp) ; \
+	cat $(depfile).pre.tmp $(depfile).dtc.tmp > $(depfile)
+
+$(obj)/%.dtbo: $(src)/%.dts $(DTC) FORCE
+	$(call if_changed_dep,dtco)
+
 DT_CHECKER ?= dt-validate
 DT_BINDING_DIR := Documentation/devicetree/bindings
 # DT_TMP_SCHEMA may be overridden from Documentation/devicetree/bindings/Makefile
--
2.34.1

